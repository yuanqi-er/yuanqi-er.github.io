<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>mysql数据库优化全剖析（二） | YuanQi</title><meta name="description" content="Mysql的体系结构概览  连接者：不同语言的代码程序和mysql的交互（SQL交互）  整个MySQL Server由以下组成：  Connection Pool：连接池组件（管理、缓冲用户的连接，线程处理等需要缓存的需求）   Management Services &amp; Utilities：管理服务和工具组件（系统管理和控制工具，例如备份恢复、Mysql复制、集群等） SQL inte"><meta name="keywords" content="mysql,数据库"><meta name="author" content="Mr.He"><meta name="copyright" content="Mr.He"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/MyFile/favicon.png"><link rel="canonical" href="http://yuanqi-er.github.io/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="mysql数据库优化全剖析（二）"><meta property="og:url" content="http://yuanqi-er.github.io/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"><meta property="og:site_name" content="YuanQi"><meta property="og:description" content="Mysql的体系结构概览  连接者：不同语言的代码程序和mysql的交互（SQL交互）  整个MySQL Server由以下组成：  Connection Pool：连接池组件（管理、缓冲用户的连接，线程处理等需要缓存的需求）   Management Services &amp; Utilities：管理服务和工具组件（系统管理和控制工具，例如备份恢复、Mysql复制、集群等） SQL inte"><meta property="og:image" content="https://pics.images.ac.cn/image/5f05e17f6eb5c.html"><meta property="article:published_time" content="2020-07-08T14:37:45.894Z"><meta property="article:modified_time" content="2020-07-08T15:09:16.548Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="mysql数据库优化全剖析（一）" href="http://yuanqi-er.github.io/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 网站</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql的体系结构概览"><span class="toc-number">1.</span> <span class="toc-text">Mysql的体系结构概览</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#存储引擎"><span class="toc-number"></span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#存储引擎概述"><span class="toc-number">1.</span> <span class="toc-text">存储引擎概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#各种存储引擎特性"><span class="toc-number">2.</span> <span class="toc-text">各种存储引擎特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB特性"><span class="toc-number">2.1.</span> <span class="toc-text">InnoDB特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#事务控制"><span class="toc-number">2.1.1.</span> <span class="toc-text">事务控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#外键约束"><span class="toc-number">2.1.2.</span> <span class="toc-text">外键约束</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#存储方式"><span class="toc-number">2.1.3.</span> <span class="toc-text">存储方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM特性"><span class="toc-number">2.2.</span> <span class="toc-text">MyISAM特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#不支持事务"><span class="toc-number">2.2.1.</span> <span class="toc-text">不支持事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#文件存储方式"><span class="toc-number">2.2.2.</span> <span class="toc-text">文件存储方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MEMORY特性"><span class="toc-number">2.3.</span> <span class="toc-text">MEMORY特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MERGE特性"><span class="toc-number">2.4.</span> <span class="toc-text">MERGE特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储引擎的选择"><span class="toc-number">3.</span> <span class="toc-text">存储引擎的选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#优化SQL步骤"><span class="toc-number"></span> <span class="toc-text">优化SQL步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看SQL执行频率"><span class="toc-number">1.</span> <span class="toc-text">查看SQL执行频率</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#查看Innodb引擎在进行增删改查影响的行数"><span class="toc-number">1.0.1.</span> <span class="toc-text">查看Innodb引擎在进行增删改查影响的行数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定位低效率执行SQL"><span class="toc-number">2.</span> <span class="toc-text">定位低效率执行SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explain分析执行计划"><span class="toc-number">3.</span> <span class="toc-text">explain分析执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#环境准备"><span class="toc-number">3.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain之id"><span class="toc-number">3.2.</span> <span class="toc-text">explain之id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain之select-type"><span class="toc-number">3.3.</span> <span class="toc-text">explain之select_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain之table"><span class="toc-number">3.4.</span> <span class="toc-text">explain之table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain之type"><span class="toc-number">3.5.</span> <span class="toc-text">explain之type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain之key"><span class="toc-number">3.6.</span> <span class="toc-text">explain之key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain之rows"><span class="toc-number">3.7.</span> <span class="toc-text">explain之rows</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain之extra"><span class="toc-number">3.8.</span> <span class="toc-text">explain之extra</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#show-profile分析SQL"><span class="toc-number">4.</span> <span class="toc-text">show profile分析SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trace分析优化器执行计划"><span class="toc-number">5.</span> <span class="toc-text">trace分析优化器执行计划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#索引的使用"><span class="toc-number"></span> <span class="toc-text">索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#验证索引提升查询效率"><span class="toc-number">1.</span> <span class="toc-text">验证索引提升查询效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引的使用-1"><span class="toc-number">2.</span> <span class="toc-text">索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#准备环境"><span class="toc-number">2.1.</span> <span class="toc-text">准备环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#避免索引失效"><span class="toc-number">2.2.</span> <span class="toc-text">避免索引失效</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-全值匹配，对索引中所有列都指定具体值。"><span class="toc-number">2.2.1.</span> <span class="toc-text">1).    全值匹配，对索引中所有列都指定具体值。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-最左前缀法则"><span class="toc-number">2.2.2.</span> <span class="toc-text">2).    最左前缀法则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-范围查询右边的列，不能使用索引"><span class="toc-number">2.2.3.</span> <span class="toc-text">3).    范围查询右边的列，不能使用索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-不要在索引列上进行运算操作，索引将失效"><span class="toc-number">2.2.4.</span> <span class="toc-text">4).    不要在索引列上进行运算操作，索引将失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-字符串不加单引号，造成索引失效"><span class="toc-number">2.2.5.</span> <span class="toc-text">5).    字符串不加单引号，造成索引失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-尽量使用覆盖索引，避免select"><span class="toc-number">2.2.6.</span> <span class="toc-text">6).    尽量使用覆盖索引，避免select*</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会用到"><span class="toc-number">2.2.7.</span> <span class="toc-text">7).    用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会用到</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-以-开头的Like模糊查询，索引失效"><span class="toc-number">2.2.8.</span> <span class="toc-text">8).    以%开头的Like模糊查询，索引失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-如果MySQL评估使用索引比全表更慢，则不使用索引"><span class="toc-number">2.2.9.</span> <span class="toc-text">9).    如果MySQL评估使用索引比全表更慢，则不使用索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-is-NULL-，-is-NOT-NULL-有时-索引失效"><span class="toc-number">2.2.10.</span> <span class="toc-text">10).    is NULL ， is NOT NULL  有时 索引失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-in走索引，not-in索引失效"><span class="toc-number">2.2.11.</span> <span class="toc-text">11).    in走索引，not in索引失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-单列索引和复合索引"><span class="toc-number">2.2.12.</span> <span class="toc-text">12).    单列索引和复合索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看索引使用情况"><span class="toc-number">3.</span> <span class="toc-text">查看索引使用情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SQL优化"><span class="toc-number"></span> <span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#大批量插入数据"><span class="toc-number">1.</span> <span class="toc-text">大批量插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1）主键顺序插入"><span class="toc-number">1.0.1.</span> <span class="toc-text">1）主键顺序插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2）关闭唯一性校验"><span class="toc-number">1.0.2.</span> <span class="toc-text">2）关闭唯一性校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3）手动提交事务"><span class="toc-number">1.0.3.</span> <span class="toc-text">3）手动提交事务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化insert语句"><span class="toc-number">2.</span> <span class="toc-text">优化insert语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化order-by语句"><span class="toc-number">3.</span> <span class="toc-text">优化order by语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#环境准备-1"><span class="toc-number">3.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两种排序方式"><span class="toc-number">3.2.</span> <span class="toc-text">两种排序方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Filesort的优化"><span class="toc-number">3.3.</span> <span class="toc-text">Filesort的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化group-by语句"><span class="toc-number">3.4.</span> <span class="toc-text">优化group by语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化嵌套查询（子查询）"><span class="toc-number">3.5.</span> <span class="toc-text">优化嵌套查询（子查询）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化or条件"><span class="toc-number">3.6.</span> <span class="toc-text">优化or条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化分页查询"><span class="toc-number">3.7.</span> <span class="toc-text">优化分页查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优化思路一"><span class="toc-number">3.7.1.</span> <span class="toc-text">优化思路一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#优化思路二"><span class="toc-number">3.7.2.</span> <span class="toc-text">优化思路二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用SQL提示"><span class="toc-number">4.</span> <span class="toc-text">使用SQL提示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#USE-INDEX"><span class="toc-number">4.1.</span> <span class="toc-text">USE INDEX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IGNORE-INDEX"><span class="toc-number">4.2.</span> <span class="toc-text">IGNORE INDEX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FORCE-INDEX"><span class="toc-number">4.3.</span> <span class="toc-text">FORCE INDEX</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pics.images.ac.cn/image/5f05e17f6eb5c.html)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">YuanQi</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 网站</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">mysql数据库优化全剖析（二）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-08 22:37:45"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-08</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-08 23:09:16"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-08</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">7.8k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 25 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="Mysql的体系结构概览"><a href="#Mysql的体系结构概览" class="headerlink" title="Mysql的体系结构概览"></a>Mysql的体系结构概览</h3><p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/1.jpg" alt="1"></p>
<blockquote>
<p>连接者：不同语言的代码程序和mysql的交互（SQL交互）</p>
</blockquote>
<p>整个MySQL Server由以下组成：</p>
<ul>
<li>Connection Pool：连接池组件<code>（管理、缓冲用户的连接，线程处理等需要缓存的需求）</code></li>
</ul>
<ul>
<li>Management Services &amp; Utilities：管理服务和工具组件<code>（系统管理和控制工具，例如备份恢复、Mysql复制、集群等）</code></li>
<li>SQL interface：SQL接口<code>（接受用户的SQL命令，并且返回用户需要查询的结果）</code></li>
<li>Parser：查询解析器<code>（SQL命令传递到解析器的时候会被解析器验证和解析(权限、语法结构) ）</code></li>
<li>Optimizer：查询优化器<code>（SQL语句在查询之前会使用查询优化器对查询进行优化）</code></li>
<li>Caches &amp; Buffers：缓存<code>（如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据）</code></li>
</ul>
<ul>
<li><p>Pluggable Storage Engines：插入式存储引擎</p>
<blockquote>
<p>存储引擎说白了就是如何管理操作数据（存储数据、如何更新、查询数据等）的一种<strong>方法</strong>。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型</p>
</blockquote>
</li>
</ul>
<ul>
<li>File System：文件系统</li>
</ul>
<p>​    和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。</p>
<p>​    这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h3 id="存储引擎概述"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述</h3><ul>
<li><p>和大多数数据库不同，MySQL中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎</p>
</li>
<li><p>存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式。</p>
</li>
<li><p>存储引擎是基于表的，而不是基于库的。所以存储引擎也成为表类型。</p>
</li>
</ul>
<ul>
<li>Oracle、SqlServer等数据库只有一种存储引擎。MySQL存在多种。</li>
<li>可以通过指令<code>show engines</code>，来查询当前数据库支持的存储引擎  </li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" alt="2"></p>
<ul>
<li>创建新表是如果不指定存储引擎，那么系统会使用默认的存储引擎。MySQL5.5之前的默认存储引擎是<code>MyISAM</code>，5.5之后就改为了<code>InnoDB</code>（default就是默认的引擎）</li>
</ul>
<h3 id="各种存储引擎特性"><a href="#各种存储引擎特性" class="headerlink" title="各种存储引擎特性"></a>各种存储引擎特性</h3><p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" alt="3"></p>
<p>（着重注意高亮的特性）</p>
<p>我们只需要重点了解<code>InnoDB和MyISAM</code>。另外两种MEMORY、MERGE了解即可。</p>
<h4 id="InnoDB特性"><a href="#InnoDB特性" class="headerlink" title="InnoDB特性"></a>InnoDB特性</h4><ul>
<li><p>InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。</p>
</li>
<li><p>但是对比MyISAM的存储引擎，InnoDB的处理效率差一点，并且会占用更多的磁盘空间以保留数据和索引。</p>
</li>
</ul>
<h5 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h5><h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><ol>
<li>使用共享表空间存储，这种方式创建的表结构保存在<code>.frm</code>文件中，数据和索引保存在<code>innodb_data_home_dir</code>和<code>innodb_data_file_path</code>定义的表空间中，可以是多个文件</li>
<li>使用多表空间存储，这种方式创建的表结构仍然存在<code>.frm</code>文件中，但是每个表的数据和索引单独保存在<code>.ibd</code>中</li>
</ol>
<h4 id="MyISAM特性"><a href="#MyISAM特性" class="headerlink" title="MyISAM特性"></a>MyISAM特性</h4><p>MyISAM不支持事务，也不支持外键，其优势是访问速度的快，对事务的完整性没有要求或者以select、insert为主的应用基本上都可以使用这个引擎来创建表，它有两个比较重要的特点：</p>
<h5 id="不支持事务"><a href="#不支持事务" class="headerlink" title="不支持事务"></a>不支持事务</h5><h5 id="文件存储方式"><a href="#文件存储方式" class="headerlink" title="文件存储方式"></a>文件存储方式</h5><p>每个MyISAM在磁盘上存储成三个文件，其文件名都和表名相同，但扩展名分别是：</p>
<p><code>.frm</code>（存储表定义）</p>
<p><code>.myd</code>（MyData，存储数据）</p>
<p><code>.myi</code>（MyIndex，存储索引）</p>
<h4 id="MEMORY特性"><a href="#MEMORY特性" class="headerlink" title="MEMORY特性"></a>MEMORY特性</h4><p>（memory——内存）</p>
<ul>
<li><p>​    Memory存储引擎将表的数据存放在内存中。每个表对应一个磁盘文件，格式是.frm，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。</p>
</li>
<li><p>​    Memory类型的表访问非常的快，因为它的数据是存放在内存中的，并且默认使用Hash索引，但是服务一旦关闭，表中的数据就会丢失。（安全没有保障）</p>
</li>
</ul>
<h4 id="MERGE特性"><a href="#MERGE特性" class="headerlink" title="MERGE特性"></a>MERGE特性</h4><ul>
<li><p>Merge存储引擎是一组MyISAM表的组合。</p>
</li>
<li><p>Merge表本身没有存储数据，对Merge类型的表进行查询更新删除操作，实际上是对内部的MyISAM表进行的。</p>
</li>
<li><p>可以对Merge表进行drop操作，但是这个操作只是删除Merge表的定义，对内部的表是没有任何影响的。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" alt="4"></p>
<h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>以下是几种常用的存储引擎的使用环境：</p>
<ul>
<li><p>InnoDB：</p>
<p>​    是MySQL的默认引擎。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。    </p>
<p>​    InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定，还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择</p>
</li>
</ul>
<ul>
<li><p>MyISAM：</p>
<p>​    如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么这个存储引擎是非常合适的</p>
</li>
</ul>
<ul>
<li><p>MEMORY：</p>
<p>​    将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。Memory的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。</p>
<p>​    Memory表通常用于更新不太频繁的小表，用以快速得到访问结果。</p>
</li>
</ul>
<ul>
<li><p>MERGE：</p>
<p>​    用于将一系列等同的Myisam表以逻辑方式组合在一起，并作为一个对象引用他们。merge表的优势在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善Merge表的访问效率。这对于存储数据诸如数据仓库等VLDB环境十分合适。</p>
</li>
</ul>
<h1 id="优化SQL步骤"><a href="#优化SQL步骤" class="headerlink" title="优化SQL步骤"></a>优化SQL步骤</h1><p>开发初期数据量小，开发人员写SQL语句更重视功能上的实现，应用上线后，随着生产数据量的急剧增长，很多SQL语句开始逐渐显露出性能问题。    因此我们要对它们进行优化。</p>
<p>当面对一个有SQL性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题SQL并尽快解决问题。</p>
<h3 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h3><p><code>show status</code>命令可以提供服务器状态信息。 （很多)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 当前连接的信息</span><br><span class="line">show status like &#39;Com_______&#39;;			-- 7个_符号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询全局的信息</span><br><span class="line">show global status like &#39;Com_______&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" alt="5"></p>
<ul>
<li>可以看出这个数据库是查询为主，还是插入为主。提供了一些<strong>借鉴性指标</strong>。</li>
</ul>
<h5 id="查看Innodb引擎在进行增删改查影响的行数"><a href="#查看Innodb引擎在进行增删改查影响的行数" class="headerlink" title="查看Innodb引擎在进行增删改查影响的行数"></a>查看Innodb引擎在进行增删改查影响的行数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询innodb引擎全局的信息</span><br><span class="line">show global status like &#39;Innodb_rows_%&#39;;</span><br></pre></td></tr></table></figure>





<h3 id="定位低效率执行SQL"><a href="#定位低效率执行SQL" class="headerlink" title="定位低效率执行SQL"></a>定位低效率执行SQL</h3><p>可以通过以下两种方式定位执行效率低的SQL语句：</p>
<ol>
<li><strong>慢查询日志</strong>：通过慢查询日志定位。用<code>--log-slow-queries[=file_name]</code> 选项启动时，mysqld写一个包含所有执行时间超过<code>--long_query_time</code>秒的SQL语句的日志文件。（后面详细讲解）</li>
<li><strong>show processlist</strong>：慢查询日志在查询结束后才记录，所以在应用反映执行效率出现问题的时候并不能定位问题，可以使用<code>show procseelist</code>命令查看当前MySQL在进行的进程，包括线程的状态、是否锁表等，可以<strong>实时地</strong>查看SQL的执行情况，同时对一些锁表操作进行优化。</li>
</ol>
<p>show processlist的示例：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" alt="6"></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/7.png" alt="7"></p>
<h3 id="explain分析执行计划"><a href="#explain分析执行计划" class="headerlink" title="explain分析执行计划"></a>explain分析执行计划</h3><p>​    通过以上步骤查询到效率低的SQL语句后，可以通过<code>explain</code>或者<code>desc</code>命令获取MySQL如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接的顺序。</p>
<ul>
<li>在任何的select语句之前加入explain，就可以输出对应的查询计划。</li>
</ul>
<p>查询SQL语句的执行计划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_item where id &#x3D; 1;			-- tb_item是有三百万数据的表</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/8.png" alt="8"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_item where title &#x3D; &#39;阿尔卡特（OT-979） 冰川白 联通3G手机3&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/9.png" alt="9"></p>
<p>表头信息的含义：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，是一组数字，表示查询中操作表的顺序</td>
</tr>
<tr>
<td>select_type</td>
<td>表示select的类型，常见的取值有simple（简单表，即不使用表连接或子查询），primary（主查询，即外层的查询），union（union中的第二个或者后面的查询语句）、subquery（子查询中的第一个select）等</td>
</tr>
<tr>
<td>table</td>
<td>输出结果的表</td>
</tr>
<tr>
<td>type</td>
<td>表的连接类型</td>
</tr>
<tr>
<td>possible_key</td>
<td>表示查询时，可能使用的索引</td>
</tr>
<tr>
<td>key</td>
<td>表示实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>索引字段的长度</td>
</tr>
<tr>
<td>rows</td>
<td>扫描行的数量</td>
</tr>
<tr>
<td>extra</td>
<td>执行情况的说明和描述</td>
</tr>
</tbody></table>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>创建表，然后再往表结构中插入几条测试记录</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/10.png" alt="10"></p>
<p>角色表、用户表、用户角色表（中间表）。</p>
<p>插入用户的测试数据、角色的测试数据，再插入关系表中的数据。</p>
<p><strong>用户表：</strong></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/11.png" alt="11"></p>
<p><strong>角色表：</strong></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/12.png" alt="12"></p>
<p><strong>用户角色的关系表：</strong></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/13.png" alt="13"></p>
<h4 id="explain之id"><a href="#explain之id" class="headerlink" title="explain之id"></a>explain之id</h4><p><strong>id字段是select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</strong></p>
<p>（如果是单表操作，意义不大）</p>
<p>id情况有三种：</p>
<ol>
<li><p>id相同表示加载表的顺序是从上到下。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/14.png" alt="14"></p>
</li>
<li><p>id不同。id值越大，优先级越高，越先被执行。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/15.png" alt="15"></p>
</li>
<li><p>id有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下执行；在所有的组中，id值越大，优先级越高，越先执行。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/16.png" alt="16"></p>
</li>
</ol>
<h4 id="explain之select-type"><a href="#explain之select-type" class="headerlink" title="explain之select_type"></a>explain之select_type</h4><p>表示select的类型，常见的取值如下图所示：</p>
<table>
<thead>
<tr>
<th>select_type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>simple</td>
<td>简单的select查询，查询中不会包含子查询或者UNION</td>
</tr>
<tr>
<td>primary</td>
<td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td>
</tr>
<tr>
<td>subquery （子查询）</td>
<td>在select或where列表中包含了子查询</td>
</tr>
<tr>
<td>derived</td>
<td>在from列表中包含的子查询，被标记为derived（衍生）MySQL会递归执行这些子查询，把结果放在临时表中（套娃出现的临时表）</td>
</tr>
<tr>
<td>union      （并集）</td>
<td>若第二个select出现在union之后，则标记为union；若union包含在from子句的子查询中，外层select将被标记为：derived</td>
</tr>
<tr>
<td>union result</td>
<td>从union表获取结果的select</td>
</tr>
</tbody></table>
<ul>
<li>从上到下效率越来越低。</li>
</ul>
<h4 id="explain之table"><a href="#explain之table" class="headerlink" title="explain之table"></a>explain之table</h4><p>展示这一行的数据是关于哪一张表的。</p>
<h4 id="explain之type"><a href="#explain之type" class="headerlink" title="explain之type"></a>explain之type</h4><p>type显示的是访问类型，是较为重要的一个指标，可取值为：</p>
<p>（大概知道SQL语句执行效率的情况）</p>
<table>
<thead>
<tr>
<th>type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>MySQL不访问任何表，索引，直接返回结果</td>
</tr>
<tr>
<td>system</td>
<td>表只有一行记录（等于系统表），这是const类型的特例，一般不会出现</td>
</tr>
<tr>
<td>const</td>
<td>表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。</td>
</tr>
<tr>
<td>eq_ref</td>
<td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td>
</tr>
<tr>
<td>ref</td>
<td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多行）</td>
</tr>
<tr>
<td>range</td>
<td>只检索给定返回的行，使用一个索引来选择行。where之后出现between，&lt;，&gt;，in等操作</td>
</tr>
<tr>
<td>index</td>
<td>index与all的区别为index类型只是遍历了索引树，通常比all快</td>
</tr>
<tr>
<td>all</td>
<td>将遍历全表以找到匹配的行</td>
</tr>
</tbody></table>
<ul>
<li><p>结果值由上到下，从好到坏。</p>
</li>
<li><p><strong>一般来说，我们至少要保证查询至少达到range级别，最好达到ref</strong></p>
</li>
</ul>
<h4 id="explain之key"><a href="#explain之key" class="headerlink" title="explain之key"></a>explain之key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">possible_keys：显示可能应用在这张表的索引，一个或多个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key：实际使用的索引，如果为NULL，则没有使用索引。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key_len：表示索引中使用的字节数，该值为索引字段**最大可能长度**，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</span><br></pre></td></tr></table></figure>

<ul>
<li>要是发现没有索引就要注意检查了</li>
</ul>
<h4 id="explain之rows"><a href="#explain之rows" class="headerlink" title="explain之rows"></a>explain之rows</h4><p>扫描的行的数量。</p>
<p>（有索引扫描一行，无索引整表查询）</p>
<h4 id="explain之extra"><a href="#explain之extra" class="headerlink" title="explain之extra"></a>explain之extra</h4><p>其他的额外的执行计划信息，在该列展示：</p>
<table>
<thead>
<tr>
<th>extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>using filesort</td>
<td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引进行读取，称为“文件排序”</td>
</tr>
<tr>
<td>using temporary</td>
<td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于order和group by</td>
</tr>
<tr>
<td>using index</td>
<td>表示相应的select操作使用了覆盖索引，避免访问表的数据行，效率不错</td>
</tr>
</tbody></table>
<ul>
<li>前面两个非常耗性能，出现了要考虑优化</li>
</ul>
<h3 id="show-profile分析SQL"><a href="#show-profile分析SQL" class="headerlink" title="show profile分析SQL"></a>show profile分析SQL</h3><p>MySQL从5.0.37版本开始增加了<code>show profile</code>和<code>show profiles</code>语句的支持。</p>
<p><code>show profiles</code>能够在做SQL优化时帮助我们<strong>了解时间都耗费哪里去了</strong></p>
<ul>
<li>通过have_profiling参数，能够看到当前Mysql是否支持profile：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@have_profiling		-- 会打印yes或者no</span><br></pre></td></tr></table></figure>

<ul>
<li>默认profiling是关闭的，可以通过set语句在Session级别开启：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select @@profiling -- 可以看到是否开启。0关闭、1开启</span><br><span class="line"></span><br><span class="line">set profiling &#x3D; 1; -- 设为1开启profiling开关。</span><br></pre></td></tr></table></figure>



<ul>
<li>show profiles可以看到我们之前所有操作的耗时</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/17.png" alt="17"></p>
<ul>
<li>通过<code>show profile for query Query_id</code>，可以查看到该SQL语句执行过程中每个线程的状态和消耗的时间。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/18.png" alt="18"></p>
<blockquote>
<p>TIP：</p>
<p>​        Sending data 状态表示MySQL线程<strong>开始访问数据行并把结果返回给客户端的过程</strong>，而不仅仅是返回个客户端。    由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整个查询中耗时最长的状态。</p>
</blockquote>
<ul>
<li>在获取到最消耗时间的线程状态后，MySQL支持进一步选择<code>all</code>、<code>cpu</code>、<code>block io</code>、<code>context switch</code>、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。</li>
</ul>
<p>例如，我们查看这条语句的cpu：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/19.png" alt="19"></p>
<h3 id="trace分析优化器执行计划"><a href="#trace分析优化器执行计划" class="headerlink" title="trace分析优化器执行计划"></a>trace分析优化器执行计划</h3><p>MySQL5.6提供了对SQL的跟踪trace，通过trace文件能够进一步了解为什么优化器选择A计划，而不是选择B计划。</p>
<ul>
<li>打开trace，设置格式为JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set optimizer_trace &#x3D; &quot;enabled&#x3D;on&quot;,end_markers_in_json&#x3D;on;	-- 开启trace</span><br><span class="line">set optimizer_trace_max_mem_size &#x3D; 1000000;   			-- 设置内存大小</span><br></pre></td></tr></table></figure>



<ul>
<li>执行SQL语句（例如执行tb_item表的id前三个）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_item where id &lt; 4;				-- 这是一个普通的例子</span><br></pre></td></tr></table></figure>



<ul>
<li>最后检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure>







<h1 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h1><p>索引是数据库优化最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的MySQL性能问题。</p>
<h3 id="验证索引提升查询效率"><a href="#验证索引提升查询效率" class="headerlink" title="验证索引提升查询效率"></a>验证索引提升查询效率</h3><p>在我们准备的表结构tb_item中，一共存储了300万条记录</p>
<ul>
<li>根据ID查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_item where id &#x3D; 1999 \G;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/20.png" alt="20"></p>
<p>根据ID查询速度非常快，因为id为<strong>主键，有索引</strong>。</p>
<ul>
<li>根据title进行精确查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_item where title&#x3D;&#39;iphoneX 移动3G 32G941&#39;\G;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/21.png" alt="21"></p>
<ul>
<li>处理方案，针对title字段，创建索引：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_item_title on tb_item(title);</span><br></pre></td></tr></table></figure>

<p>可能耗费多的时间（51.51sec），数据库底层正在重建索引</p>
<ul>
<li>索引创建完成后，再次进行查询：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_item where title&#x3D;&#39;三星 Note II （N7100） 云石白 联通3G手机8&#39;\G;</span><br></pre></td></tr></table></figure>

<p>这时的执行效率为0.01s，瞬间提速！</p>
<h3 id="索引的使用-1"><a href="#索引的使用-1" class="headerlink" title="索引的使用"></a>索引的使用</h3><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/22.png" alt="22"></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/23.png" alt="23"></p>
<p>对name、status、address三个字段创建了索引。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/24.png" alt="24"></p>
<h4 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h4><h5 id="1-全值匹配，对索引中所有列都指定具体值。"><a href="#1-全值匹配，对索引中所有列都指定具体值。" class="headerlink" title="1).    全值匹配，对索引中所有列都指定具体值。"></a>1).    <strong>全值匹配</strong>，对索引中所有列都指定具体值。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name&#x3D;&#39;小米科技&#39; and status&#x3D;&#39;1&#39; and address&#x3D;&#39;西安市&#39; \G;</span><br></pre></td></tr></table></figure>

<p>explain查看执行计划。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/25.png" alt="25"></p>
<h5 id="2-最左前缀法则"><a href="#2-最左前缀法则" class="headerlink" title="2).    最左前缀法则"></a>2).    <strong>最左前缀法则</strong></h5><p>如果索引了多列，要遵守最左前缀法则。<strong>指的是查询从索引的最左前列开始，并且不跳过索引中的列。</strong></p>
<blockquote>
<p>根据我们的索引，查询要包含最左的name，并且不能跳过status直接跨到address来。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/26.png" alt="26"></p>
<p>和where后面的顺序无关，<code>status and address and name</code> 那也是走索引的。</p>
<ul>
<li>如果不遵守最左前缀法则，就不会走索引。</li>
</ul>
<ul>
<li>我们发现，我们跳过中间的status也会走索引。但是因为违反最左前缀法则，实际上只走了name的索引，而address的索引是失效的。</li>
</ul>
<h5 id="3-范围查询右边的列，不能使用索引"><a href="#3-范围查询右边的列，不能使用索引" class="headerlink" title="3).    范围查询右边的列，不能使用索引"></a>3).    <strong>范围查询右边的列，不能使用索引</strong></h5><ul>
<li>之前我们都是使用<strong>精确匹配</strong>，如果我们把<code>status=&#39;1&#39;</code>改为<code>status&gt;&#39;1&#39;</code>，status就变成了范围查询</li>
<li>当status使用的范围查询后，它右边的address就不能使用索引了。</li>
</ul>
<p>（要注意避免这种情况）</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/27.png" alt="27"></p>
<h5 id="4-不要在索引列上进行运算操作，索引将失效"><a href="#4-不要在索引列上进行运算操作，索引将失效" class="headerlink" title="4).    不要在索引列上进行运算操作，索引将失效"></a>4).    <strong>不要在索引列上进行运算操作，索引将失效</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_seller where substring(name,3,2) &#x3D; &#39;科技&#39;;</span><br><span class="line"></span><br><span class="line">-- 这是查询name中，第三个字符开始截取两个字符，这两个字符为‘科技’的匹配项</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/28.png" alt="28"></p>
<p>这是不使用索引的。</p>
<h5 id="5-字符串不加单引号，造成索引失效"><a href="#5-字符串不加单引号，造成索引失效" class="headerlink" title="5).    字符串不加单引号，造成索引失效"></a>5).    <strong>字符串不加单引号，造成索引失效</strong></h5><p>虽然写不写单引号都能查询到对应数据（仅对应数字），但是不写索引就会失效。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/29.png" alt="29"></p>
<h5 id="6-尽量使用覆盖索引，避免select"><a href="#6-尽量使用覆盖索引，避免select" class="headerlink" title="6).    尽量使用覆盖索引，避免select*"></a>6).    <strong>尽量使用覆盖索引，避免select*</strong></h5><p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select*</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/30.png" alt="30"></p>
<p>我们发现不使用select*，Extra变了。</p>
<ul>
<li>如果查询列，超出索引列，也会降低性能（就是查了没有索引的password）</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/31.png" alt="31"></p>
<p>因为所有没有password，所以要回表查询。</p>
<blockquote>
<p>TIP：</p>
<p><strong>using index</strong>：使用覆盖索引的时候就会出现</p>
<p><strong>using where</strong>：在查找使用索引的情况下，需要回表去查询所需的数据</p>
<p><strong>using index condition</strong>：查找使用了索引，但是需要回表查询数据</p>
<p><strong>using index ; using where</strong>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p>
</blockquote>
<ul>
<li>所以使用覆盖查询，避免回表查询</li>
</ul>
<h5 id="7-用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会用到"><a href="#7-用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会用到" class="headerlink" title="7).    用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会用到"></a>7).    <strong>用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会用到</strong></h5><p>示例：name是索引列，而createtime不是索引列，中间是or进行连接是不走索引的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_seller where name&#x3D;&#39;黑马程序员&#39; or createtime&#x3D;&#39;2088-01-01 12:00:00&#39; \G;</span><br></pre></td></tr></table></figure>

<ul>
<li>整段索引都失效！</li>
</ul>
<h5 id="8-以-开头的Like模糊查询，索引失效"><a href="#8-以-开头的Like模糊查询，索引失效" class="headerlink" title="8).    以%开头的Like模糊查询，索引失效"></a>8).    <strong>以%开头的Like模糊查询，索引失效</strong></h5><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_seller where name like &#39;科技%&#39;;</span><br><span class="line">-- 我们查询的内容是以科技开始的，索引是生效的</span><br><span class="line"></span><br><span class="line">select * from tb_seller where name like &#39;%科技&#39;;</span><br><span class="line">-- 我们查询的内容是以科技结尾的，索引失效</span><br><span class="line"></span><br><span class="line">&#39;%科技%&#39;	-- 这样也是索引失效</span><br></pre></td></tr></table></figure>

<ul>
<li>只要是模糊匹配，%加在了前面，索引失效</li>
</ul>
<p>这个问题我们可以用覆盖索引来解决这类问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select sellerid from tb_seller where name like &#39;%科技%&#39;;</span><br><span class="line">-- 使用覆盖索引，而不是select*，就会使用索引了</span><br><span class="line"></span><br><span class="line">-- 模糊匹配，查询的列包含不是索引的列，索引直接失效！！</span><br></pre></td></tr></table></figure>





<h5 id="9-如果MySQL评估使用索引比全表更慢，则不使用索引"><a href="#9-如果MySQL评估使用索引比全表更慢，则不使用索引" class="headerlink" title="9).    如果MySQL评估使用索引比全表更慢，则不使用索引"></a>9).    <strong>如果MySQL评估使用索引比全表更慢，则不使用索引</strong></h5><p>如果我只查address的索引，但是不符合最左前缀原则，不走索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_seller where address&#x3D;&#39;北京市&#39;;</span><br></pre></td></tr></table></figure>



<p>我们要单独为address建立索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_seller_address on tb_seller(address)</span><br></pre></td></tr></table></figure>



<p>我们再测试查找address的索引：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/32.png" alt="32"></p>
<ul>
<li>发现虽然有索引，但实际并没有走索引。</li>
</ul>
<p>再测试西安市的地址查询：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/33.png" alt="33"></p>
<ul>
<li>走索引了！    同样一条SQL语句，为什么会有两种扫描方式？</li>
</ul>
<p>​    这是因为MySQL的底层的执行器在解析执行计划的时候，发现12条数据11条都是北京市，还不如全表扫描走得快，就放弃索引了。</p>
<h5 id="10-is-NULL-，-is-NOT-NULL-有时-索引失效"><a href="#10-is-NULL-，-is-NOT-NULL-有时-索引失效" class="headerlink" title="10).    is NULL ， is NOT NULL  有时 索引失效"></a>10).    is NULL ， is NOT NULL  有时 索引失效</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_seller where address is null;	-- 查询address列中为空的</span><br><span class="line"></span><br><span class="line">select * from tb_seller where address is not null;	-- 查询address列中不为空的</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们发现，在这里<code>is null</code>走了索引。<code>is not null</code>没有走索引。</p>
<p>​    这个和上一个差不多意思，因为空的没有或者比较少，所以就通过索引来找。非空占了大部分，就还不如走全表扫描</p>
</li>
</ul>
<h5 id="11-in走索引，not-in索引失效"><a href="#11-in走索引，not-in索引失效" class="headerlink" title="11).    in走索引，not in索引失效"></a>11).    in走索引，not in索引失效</h5><p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/34.png" alt="34"></p>
<ul>
<li>编写时尽量使用<code>in</code>，别使用<code>not in</code></li>
</ul>
<h5 id="12-单列索引和复合索引"><a href="#12-单列索引和复合索引" class="headerlink" title="12).    单列索引和复合索引"></a>12).    单列索引和复合索引</h5><p>​    结论：尽量使用复合索引，而少使用单列索引。</p>
<p>​    当我们创建了三个单列索引的时候，我们进行多字段搜索的时候，它只会使用一个索引。而这个索引，是数据库底层选择的最优的索引。</p>
<p>（最优的方法也基本是之前的思路，看占比）</p>
<h3 id="查看索引使用情况"><a href="#查看索引使用情况" class="headerlink" title="查看索引使用情况"></a>查看索引使用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show status like &#39;Handler_read%&#39;;</span><br><span class="line"></span><br><span class="line">show global status like &#39;Handler_read%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/35.png" alt="35"></p>
<p>这些指标的意思不作重点掌握，自己了解即可。</p>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><p>环境准备：</p>
<p>创建两张表，<code>tb_user_1</code> 和<code>tb_user_2</code></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/36.png" alt="36"></p>
<p>往这两张表中分别导入100万条记录。</p>
<p>当使用<code>load</code>命令导入数据的时候，适当的设置可以提高导入的效率。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/37.png" alt="37"></p>
<p>对于InnoDB类型的表，有以下几种方式可以提高导入的效率：</p>
<h5 id="1）主键顺序插入"><a href="#1）主键顺序插入" class="headerlink" title="1）主键顺序插入"></a>1）主键顺序插入</h5><p>​    因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。</p>
<p>​    如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入的效率。</p>
<blockquote>
<p>脚本文件介绍：</p>
<p>​            sql1.log   ——→    主键有序</p>
<p>​            sql2.log   ——→    主键无序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">load data local infile&#39;&#x2F;root&#x2F;sql1.log&#39; in table &#39;tb_user_1&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;		-- 有序的（19.37sec）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">load data local infile&#39;&#x2F;root&#x2F;sql2.log&#39; in table &#39;tb_user_1&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;		-- 无序的（1min 51.42sec）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 还要标明文件中：	域以&#39;,&#39;分隔。  行以&#39;\n&#39;就是回车分隔</span><br></pre></td></tr></table></figure>





<h5 id="2）关闭唯一性校验"><a href="#2）关闭唯一性校验" class="headerlink" title="2）关闭唯一性校验"></a>2）关闭唯一性校验</h5><p>在导入数据前执行<code>SET UNIQUE_CHECKS=0</code>，关闭唯一性校验，在导入结束后执行<code>SET UNIQUE_CHECKS=1</code>，恢复唯一性校验，可以提高导入的效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET UNIQUE_CHECKS&#x3D;0	-- 关闭</span><br><span class="line"></span><br><span class="line">	-- 导入成功后</span><br><span class="line"></span><br><span class="line">SET UNIQUE_CHECKS&#x3D;1	-- 开启</span><br></pre></td></tr></table></figure>





<h5 id="3）手动提交事务"><a href="#3）手动提交事务" class="headerlink" title="3）手动提交事务"></a>3）手动提交事务</h5><p>如果应用使用自动提交的方式，建议在导入前执行<code>SET AUTOCOMMIT=0</code>，关闭自动提交，导入结束后再执行 <code>SET AUTOCOMMIT=1</code>，打开自动提交，也可以提高导入了效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET AUTOCOMMIT&#x3D;0	-- 关闭</span><br><span class="line"></span><br><span class="line">	-- 导入成功后</span><br><span class="line"></span><br><span class="line">SET AUTOCOMMIT&#x3D;1	-- 开启</span><br></pre></td></tr></table></figure>







<h3 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h3><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p>
<ul>
<li><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句。</p>
<p>这种方式将大大的缩减客户端与数据库的连接，关闭等消耗。</p>
</li>
</ul>
<p>原始方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br></pre></td></tr></table></figure>

<p>优化后的方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;);</span><br></pre></td></tr></table></figure>





<ul>
<li>在事务中进行数据插入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start transaction;		</span><br><span class="line"></span><br><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line"></span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>





<ul>
<li>数据有序插入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_test values(4,&#39;Tim&#39;);</span><br><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line"></span><br><span class="line">-- 优化后</span><br><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line">insert into tb_test values(4,&#39;Tim&#39;);</span><br></pre></td></tr></table></figure>





<h3 id="优化order-by语句"><a href="#优化order-by语句" class="headerlink" title="优化order by语句"></a>优化order by语句</h3><p>order by为排序表达式，用于指定排序的依据，它可以是字段名也可以是字段别名（默认升序）</p>
<h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/C:%5CUsers%5C%E7%BC%98%E8%B5%B7%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1593406080601.png" alt="1593406080601"></p>
<p>创建表，插入数据，创建复合索引</p>
<h4 id="两种排序方式"><a href="#两种排序方式" class="headerlink" title="两种排序方式"></a>两种排序方式</h4><p>1).    第一种是通过对返回数据进行排序，也就是通常说的filesort排序，所有不是通过索引直接返回排序结果的排序都叫<code>FileSort</code>排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age;			<span class="comment">-- 升序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;	<span class="comment">-- 降序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单字段升降序，多字段升降序，都不会使用索引（效率低）</span></span><br></pre></td></tr></table></figure>



<p>2).    第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高（使用覆盖索引）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age;	<span class="comment">-- id是有索引的，这样就会使用到索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果select id,age,salary,name。` 但是name没有索引，就不会使用索引了</span></span><br></pre></td></tr></table></figure>



<p><strong>多字段排序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,age,salary from emp order by age,salary;		-- 根据age和salary排序</span><br></pre></td></tr></table></figure>

<ol>
<li>如果两个条件一个升序<code>age asc</code>，一个降序<code>salary desc</code>，就会出现using filesort。尽量避免！</li>
<li>多字段排序的顺序需要和索引的<strong>顺序保持一致</strong></li>
</ol>
<blockquote>
<p>尽量减少额外的排序，通过索引直接返回有序数据。where条件和Order by使用相同的索引，并且Order by的顺序和索引的顺序相同，并且Order by的字段都是升序或者都是降序。</p>
</blockquote>
<h4 id="Filesort的优化"><a href="#Filesort的优化" class="headerlink" title="Filesort的优化"></a>Filesort的优化</h4><p>​    通过创建合适的索引，能减少Filesort的出现，但是在某些情况下，条件限制不能让Filesort消失，那么就需要加快Filesort的操作。</p>
<p>​    对于Filesort，MySQL有两种排序算法：</p>
<ul>
<li><strong>两次扫描算法：</strong>MySQL4.1之前使用这个。首先根据<strong>排序字段和行指针</strong>在sort buffer中排序，完成排序后，拿着<strong>行指针回表读取记录</strong>。（该操作可能会导致大量的I/O操作，性能不好）</li>
</ul>
<ul>
<li><strong>一次扫描算法：</strong>一次性取出所有满足条件的字段，然后再排序区sort buffer中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要搞。 </li>
</ul>
<p>​    MySQL通过比较系统变量<code>max_length_for_sort_data</code>的大小和<code>Query语句</code>取出字段的大小，来判定用哪一种排序算法，如果max_length_for_sort_data更大，那么使用第二种优化之后的算法；否则使用第一种。</p>
<p>​    可以适量<strong>提高</strong><code>sort_buffer_size</code>和<code>max_length_for_sort_data</code>系统变量，来增大排序区的大小，提高排序的效率。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/38.png" alt="38"></p>
<h4 id="优化group-by语句"><a href="#优化group-by语句" class="headerlink" title="优化group by语句"></a>优化group by语句</h4><p>由于group by实际上也同样会进行排序操作，而且与order by相比，group by主要只是多了排序之后的分组操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select age,count(*) from emp group by age;</span><br><span class="line">-- 对于age列，count列计数，进行age的排序。 </span><br><span class="line"></span><br><span class="line">-- Using temporary;Using filesort</span><br></pre></td></tr></table></figure>



<ul>
<li>在by age后面加上<code>order by null</code>，只分组不排序，加快效率</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select age,count(*) from emp group by age order by null;</span><br><span class="line">-- Using temporary</span><br></pre></td></tr></table></figure>

<ul>
<li>然后我们可以<strong>创建索引</strong>提高效率，就可以Using index了</li>
</ul>
<h4 id="优化嵌套查询（子查询）"><a href="#优化嵌套查询（子查询）" class="headerlink" title="优化嵌套查询（子查询）"></a>优化嵌套查询（子查询）</h4><p>Mysql4.1版本之后，开始支持SQL的子查询。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p>
<p>我们之前有角色表，用户表，用户角色中间表三个表。</p>
<p>示例，查找有角色的所有的用户信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id in (select user_id from user_role);</span><br><span class="line">-- 我们在user_role这张表中能查到用户id，再根据这个用户id查询对应的用户信息。</span><br></pre></td></tr></table></figure>



<p>使用多表联查替换子查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user u , user_role ur where u.id&#x3D;ur.user_id;</span><br></pre></td></tr></table></figure>







<h4 id="优化or条件"><a href="#优化or条件" class="headerlink" title="优化or条件"></a>优化or条件</h4><p>对于包含or的查询子句，如果要利用索引，则or之间的每个条件列都必须用到索引，而且<strong>不能使用到复合索引</strong>；如果没有索引，则应该考虑增加索引</p>
<blockquote>
<p>不能复合索引是指：or 两边的列不能同是一个复合索引。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">or</span> age=<span class="number">30</span>;</span><br></pre></td></tr></table></figure>



<p>但是！！建议使用union（并集）替换or：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select*from emp where id&#x3D;1 union select*from emp where id&#x3D;10;</span><br></pre></td></tr></table></figure>





<h4 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h4><blockquote>
<p>limit 10：查询第一页，10条记录</p>
<p>limit 10,10：查询第二页，10条记录</p>
<p>limit 20,10</p>
</blockquote>
<p>​    一般分页查询时，通过创建覆盖索引能够比较好地提高性能。</p>
<p>​    一个常见又非常头疼的问题<code>limit 2000000,10</code>，此时需要MySQL排序前2000010记录，却仅仅返回2000000-2000010的记录，其他记录丢失，查询排序的代价很大。</p>
<h5 id="优化思路一"><a href="#优化思路一" class="headerlink" title="优化思路一"></a>优化思路一</h5><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_item <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item t , (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">form</span> tb_item <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id = a.id;</span><br></pre></td></tr></table></figure>



<h5 id="优化思路二"><a href="#优化思路二" class="headerlink" title="优化思路二"></a>优化思路二</h5><p>该方案<strong>仅适用于主键自增的表</strong>，可以把Limit查询转换成某个位置的查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2000000</span> <span class="keyword">limit</span> <span class="number">10</span>;	<span class="comment">-- id走索引了，贼快</span></span><br></pre></td></tr></table></figure>

<p>（主键自增，还不能出现断层）</p>
<h3 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h3><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化的目的。</p>
<h4 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h4><p>在查询语句中<strong>表名的后面</strong>，添加use index来提供希望MySQL去参考的索引列表，可以让MySQL不在考虑其他可用的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">						<span class="comment">-- 表中有name的单列索引和复合索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;		</span><br><span class="line"><span class="comment">-- 使用了单列索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">use</span> <span class="keyword">index</span>(idx_seller_name_status) <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>; 		<span class="comment">-- 使用了我们指定的复合索引</span></span><br></pre></td></tr></table></figure>



<h4 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h4><p>ignore index和use index 恰恰<strong>相反</strong>，也是写在表名的后面，意思是让数据库忽略一个或多个索引。</p>
<h4 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h4><p>为<strong>强制</strong>MySQL使用一个特定的索引。</p>
<p>例如我们之前的例子，北京市太多了，可能有索引也不会走，我们可以强制他用索引。</p>
<p>use index只是给数据库参考，它可以不接受你的参考。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Mr.He</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yuanqi-er.github.io/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/">http://yuanqi-er.github.io/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yuanqi-er.github.io" target="_blank">YuanQi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a></div><div class="post_share"><div class="social-share" data-image="https://pics.images.ac.cn/image/5f05e17f6eb5c.html" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="next-cover" data-src="https://pics.images.ac.cn/image/5f058cf464761.html" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">mysql数据库优化全剖析（一）</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/07/mysql数据库优化全剖析（一）/" title="mysql数据库优化全剖析（一）"><img class="relatedPosts_cover" data-src="https://pics.images.ac.cn/image/5f058cf464761.html"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-07</div><div class="relatedPosts_title">mysql数据库优化全剖析（一）</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Mr.He</div><div class="footer_custom_text">Hi, welcome to my <a href="https://yuanqi-er.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="159417626918"></script></body></html>