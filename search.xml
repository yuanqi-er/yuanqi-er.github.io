<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql数据库优化全剖析（一）</title>
    <url>/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>什么是索引？索引的作用？</p>
<hr>
<p>索引（index）是帮助MySQL<strong>高效获取数据的数据结构</strong>。</p>
<blockquote>
<p>如果表中有成千上万的数据，没有索引遍历查找效率慢</p>
<p>例如用二叉树提高查询效率</p>
</blockquote>
<p>作用：高效获取数据</p>
<h3 id="优势劣势"><a href="#优势劣势" class="headerlink" title="优势劣势"></a>优势劣势</h3><p>优势：</p>
<ol>
<li>快速查询数据</li>
<li>通过索引排序，降低排序成本</li>
</ol>
<p>劣势：</p>
<ol>
<li>索引列也是要占空间的（一般放在磁盘）</li>
<li>降低更新表的效率（insert、update、delete）</li>
</ol>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>索引是在MySQL的存储引擎层中实现的，不是在服务器层实现的。</p>
<p>MySQL目前提供了以下种索引：</p>
<ul>
<li>BTREE索引：最<strong>常见</strong>的索引类型，大部分索引都支持B树索引（主要讲解）</li>
<li>HASH索引</li>
<li>R-tree索引（空间索引）</li>
<li>Full-text索引（全文索引）</li>
</ul>
<ol>
<li>我们平常说的索引，没有特别指明，都是指<strong>B+树</strong>（多路搜索树，并不一定是二叉的）结构组织的索引。 </li>
<li>聚集索引、复合索引、前缀索引、唯一索引默认都是使用B+树索引，统称为 索引</li>
<li>默认的引擎InnoDB主要支持BTREE索引</li>
</ol>
<h4 id="BTREE结构"><a href="#BTREE结构" class="headerlink" title="BTREE结构"></a>BTREE结构</h4><p>BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：</p>
<ul>
<li>每个节点最多包含m个分支</li>
<li>除根结点和叶子结点外，每个节点至少有<code>[ceil(m/2)]</code>个孩子。<code>除于2向上取整</code></li>
<li>根结点不是叶子节点，则至少有两个孩子</li>
<li>所有的叶子节点都在同一层</li>
<li>每个非叶子节点由n个key和n+1个指针组成 <code>[ceil(m/2)-1] &lt;= n &lt;= m-1</code></li>
</ul>
<hr>
<p>不懂？以5叉BTree为例：</p>
<p>m=5。由公式可得n的取值为<code>2 &lt;= n &lt;= 4</code>。当n&gt;4时，中间节点分裂到父结点，两边节点分裂</p>
<blockquote>
<p><strong>插入CNGAHEKQMFWLTZDPRXYS数据为例:</strong></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/1.png" alt="1"></p>
<p>因为key最大为4，我们插入4个。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/2.png" alt="2"></p>
<p>H是在G和N之间插入，把G变成了中间节点，中间节点变成了父结点，两边节点分裂</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/3.png" alt="3"></p>
<p>小的放左边，大的放右边，因为n没有大于4，所有不需要分裂。</p>
<p><strong>n个key的n+1个指针就是下面那个格子。这个指针就是指向左边或右边的数据块</strong></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/4.png" alt="4"></p>
<p>M插入K和N中间，n&gt;5，中间节点M向上分裂，两边节点分裂</p>
<p>​        5）.插入F W L T不需要分裂</p>
<p>​        6）.插入Z，中间元素T向上分裂到父结点中（现在父结点有G M T了）</p>
<p>​        7）.插入D，中间元素D向上分裂到父结点，然后插入P R X Y不需要分裂</p>
<p>​        <img src= "/img/loading.gif" data-src="/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/5.png" alt="5"></p>
<p>连续两个节点n&gt;5，两个中间节点向上分裂。</p>
<p>中间的指针指向的是在这两个数据范围之间的数据。</p>
</blockquote>
<ul>
<li>BTREE树和二叉树相比，查询数据的效率更高，因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快</li>
</ul>
<h4 id="B-TREE结构"><a href="#B-TREE结构" class="headerlink" title="B+TREE结构"></a>B+TREE结构</h4><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p>
<ol>
<li>n叉B+树最多含有n个key。而B树最多含有n-1个key</li>
<li>B+树的叶子节点保存所有的key消息，依key大小顺序排列</li>
<li>所有的非叶子节点都可以看作是key的索引部分（<strong>非叶子结点：目录</strong>）</li>
</ol>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/6.png" alt="6"></p>
<ul>
<li>由于B+树只有叶子节点保存key信息，查询任何的key都要从root走到叶子。所以B+树的查询效率更加稳定。</li>
</ul>
<h4 id="MySQL中的B-Tree"><a href="#MySQL中的B-Tree" class="headerlink" title="MySQL中的B+Tree"></a>MySQL中的B+Tree</h4><p>MySQL索引数据结构对经典的B+Tree进行了优化。</p>
<p>在原来的基础上，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，<strong>提高区间访问的性能</strong>。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/7.png" alt="7"></p>
<ul>
<li>例如找9-15的数据，可以直接从9通过指针直接找到后面的数据</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值<code>（就是一列不重复的数据）</code></li>
<li>复合索引：即一个索引包含多个列</li>
</ol>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建两个表结构：</span><br><span class="line">CREATE TABLE &#96;country&#96; (</span><br><span class="line">     &#96;country_id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">     &#96;country_name&#96; varchar(100) NOT NULL,</span><br><span class="line">     PRIMARY KEY (&#96;country_id&#96;)</span><br><span class="line">     ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;city&#96; (</span><br><span class="line">   &#96;city_id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">   &#96;city_name&#96; varchar(50) NOT NULL,</span><br><span class="line">   &#96;country_id&#96; int(11) NOT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;city_id&#96;)</span><br><span class="line">     ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">     </span><br><span class="line">表中插入数据:</span><br><span class="line">insert into &#96;city&#96;(&#96;city_id&#96;,&#96;city_name&#96;,&#96;country_id&#96;)values(1,&#39;西安&#39;,1);</span><br><span class="line">insert into &#96;city&#96;(&#96;city_id&#96;,&#96;city_name&#96;,&#96;country_id&#96;)values(2,&#39;NewYork&#39;,2);</span><br><span class="line">insert into &#96;city&#96;(&#96;city_id&#96;,&#96;city_name&#96;,&#96;country_id&#96;)values(3,&#39;北京&#39;,1);</span><br><span class="line">insert into &#96;city&#96;(&#96;city_id&#96;,&#96;city_name&#96;,&#96;country_id&#96;)values(4,&#39;上海&#39;,1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into &#96;country&#96; (&#96;country_id&#96;,&#96;country_name&#96;) values(1,&#39;China&#39;);</span><br><span class="line">insert into &#96;country&#96; (&#96;country_id&#96;,&#96;country_name&#96;) values(2,&#39;America&#39;);</span><br><span class="line">insert into &#96;country&#96; (&#96;country_id&#96;,&#96;country_name&#96;) values(3,&#39;Japan&#39;);</span><br><span class="line">insert into &#96;country&#96; (&#96;country_id&#96;,&#96;country_name&#96;) values(4,&#39;UK&#39;);</span><br></pre></td></tr></table></figure>

<p>用 <code>show tables;</code>可以查看现在的所有表<br>用 <code>select * from 表名</code>可以查看这个表的数据</p>
<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_city_name on city(city_name)</span><br></pre></td></tr></table></figure>

<ul>
<li>创建city表中的city_name作为索引，名字为idx_city_name</li>
</ul>
<h5 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show index from table_name; </span><br><span class="line"></span><br><span class="line">show index from table_name\G;  后面加上 \G 会变换格式</span><br></pre></td></tr></table></figure>

<ul>
<li>MySQL会对主键默认创建一个索引</li>
</ul>
<h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX 索引名称 ON 表名称;</span><br></pre></td></tr></table></figure>



<h5 id="ALTER命令"><a href="#ALTER命令" class="headerlink" title="ALTER命令"></a>ALTER命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.alter table tb_name add primary key(column_list);</span><br><span class="line">	该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL</span><br><span class="line">	</span><br><span class="line">2.alter table tb_name add unique index_name(column_list);</span><br><span class="line">	这条语句创建索引的值必须是唯一的（null可以多次出现）</span><br><span class="line">	</span><br><span class="line">3.alter table tb_name add index index_name(column_list);</span><br><span class="line">	添加普通索引，索引值可以重复</span><br><span class="line">	</span><br><span class="line">4.alter table tb_name add fulltext index_name(column_list);</span><br><span class="line">	该语句指定了索引为FULLTEXT，用于全文索引</span><br></pre></td></tr></table></figure>





<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>创建索引是尽量考虑这些已有的原则：</p>
<ul>
<li><p>对查询频次较高，且数据量较大的表建立索引</p>
</li>
<li><p>索引字段的选择，最佳候选列应当从where子句的条件中提取</p>
</li>
<li><p>使用唯一索引。区分度越高，索引的效率越高</p>
</li>
<li><p>索引不是越多越好</p>
</li>
<li><p>使用短索引。</p>
</li>
<li><p>利用最左前缀，N个列组合而成的组合索引，相当于创建了N个索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建复合索引：</span><br><span class="line">	CREATE INDEX idx_name_email_status ON tb_seller(Name,email,STATUS);</span><br><span class="line">	</span><br><span class="line">就相当于：</span><br><span class="line">	对name 创建索引；</span><br><span class="line">	对name ，email 创建了索引</span><br><span class="line">	对name ，email ，status 创建了索引</span><br><span class="line"></span><br><span class="line">按照name进行查询时有索引，按照name ，email查询时也有索引。。。</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>视图（View）是一种虚拟存在的表。</p>
<p>通俗的将，视图就是一条SELECT语句执行后返回的结果集。</p>
<p>视图相对于普通的表的优势：</p>
<ul>
<li>简单</li>
<li>安全</li>
<li>数据独立</li>
</ul>
<h3 id="创建或修改视图"><a href="#创建或修改视图" class="headerlink" title="创建或修改视图"></a>创建或修改视图</h3><p>创建视图的语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]   创建or替换</span><br><span class="line"></span><br><span class="line">VIEW view_name [(column_list)]</span><br><span class="line"></span><br><span class="line">AS select_statement</span><br><span class="line"></span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]	 这个选项决定了是否允许更新数据使记录不再满足视图的条件</span><br><span class="line"></span><br><span class="line">	LOCAL ：只要满足本视图的条件就可以更新</span><br><span class="line">	CASCADED ：必须满足所有针对该视图的所有视图条件才可以更新。（默认值）</span><br></pre></td></tr></table></figure>



<ul>
<li><p>视图就是表，怎么操作表就怎么操作视图。</p>
</li>
<li><p>能更新但不建议更新，因为视图就是用来简化查询操作的</p>
</li>
</ul>
<p>修改视图的语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">VIEW view_name [(column_list)]</span><br><span class="line">AS select_statement</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure>



<p>示例，创建city_country_view视图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace view city_country_view</span><br><span class="line">as</span><br><span class="line">select t.* , c.country_name from country c , city t where c.country_id&#x3D;t.country_id;</span><br></pre></td></tr></table></figure>



<h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><p><code>show tables</code> 命令不仅显示表的名字，也会显示视图的名字</p>
<p>同样的，使用<code>show table status</code>命令也是。</p>
<p>如果需要查询某个视图的定义，可以使用<code>show create view 视图名称 \G</code>命令进行查看</p>
<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT | CASCADE]</span><br></pre></td></tr></table></figure>

<p>示例，删除视图city_country_view:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW city_country_view ;</span><br></pre></td></tr></table></figure>





<h1 id="储存过程和函数"><a href="#储存过程和函数" class="headerlink" title="储存过程和函数"></a>储存过程和函数</h1><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>存储过程和函数是 <strong>事先经过编译并存储在数据库中的一段SQL语句的集合</strong>。调用可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率有好处</p>
<ul>
<li>过程：是一个没有返回值的函数</li>
</ul>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure procedure_name ([proc_parameter[,...]])</span><br><span class="line">begin</span><br><span class="line">	-- SQL语句</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">create procedure pro_test()</span><br><span class="line">begin</span><br><span class="line">select &#39;Hello MySQL&#39;;		</span><br><span class="line">end$					&#x2F;&#x2F;$表示分隔符</span><br><span class="line"></span><br><span class="line">delimiter;				&#x2F;&#x2F;结束这个替换</span><br></pre></td></tr></table></figure>

<ul>
<li>分号是结束符，输入了就会立刻执行，但是我们要写end怎么办</li>
<li><code>delimiter $</code>声明把第一个分隔符替换为$，不会立刻执行语句，使得我们可以输入end</li>
</ul>
<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call procedure_name();</span><br></pre></td></tr></table></figure>

<p>call关键字即可。</p>
<h3 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询db_name数据库中的所有存储过程</span><br><span class="line">select name from mysql.proc where db&#x3D;&#39;db_name&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询存储过程的状态信息</span><br><span class="line">show procedure status;</span><br><span class="line"></span><br><span class="line">-- 查询某个存储过程的定义</span><br><span class="line">show create procedure test.pro_test \G;</span><br></pre></td></tr></table></figure>

<p>也可以通过SQLyog界面查看。</p>
<h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop procedure 存储过程的名字 ;</span><br></pre></td></tr></table></figure>



<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>存储过程是可以编程的，意味着可以使用变量，表达式，控制结构，来完成比较复杂的功能</p>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul>
<li>declare</li>
</ul>
<p><strong>通过declare可以定义一个局部变量，该变量的作用范围只能在begin…end块中</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare var_name type [default value]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">create procedure pro_test1()           -- 创建存储过程	</span><br><span class="line">begin</span><br><span class="line">	declare num int default 5;        -- 声明变量 int num &#x3D; 5  </span><br><span class="line">	select concat(&#39;num的值为：&#39;, num);      -- 输出</span><br><span class="line">end$</span><br><span class="line">	</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<p>用call 调用存储过程就可以输出了。</p>
<ul>
<li>set</li>
</ul>
<p><strong>直接赋值使用set，可以赋常量或者赋表达式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set var_name &#x3D; expr [, var_name &#x3D; expr]...</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">create procedure pro_test2()         	</span><br><span class="line">begin</span><br><span class="line">	declare num int default 0;</span><br><span class="line">	set num &#x3D; num+10;</span><br><span class="line">	select num;</span><br><span class="line">end$</span><br><span class="line">	</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>



<ul>
<li>也可以通过select…into方式进行赋值操作：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">create procedure pro_test3()         	</span><br><span class="line">begin</span><br><span class="line">	declare num int;     -- 这里没给默认值</span><br><span class="line">	select count(*) into num from city;  -- 将查询city元素个数的结果返回赋值给 num</span><br><span class="line">	select concat(&#39;city表中的记录数为：&#39; , num);</span><br><span class="line">end$</span><br><span class="line">	</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>



<h5 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h5><p>语法结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if search_condition then statement_list       -- if 满足这个  then 执行这个</span><br><span class="line">	</span><br><span class="line">	[elseif ... then ...]</span><br><span class="line">	[else ...]</span><br><span class="line">	</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test4()</span><br><span class="line">begin</span><br><span class="line">	declare height int default 175;</span><br><span class="line">	declare description varchar(50) default &#39;&#39;;</span><br><span class="line">	if height &gt;&#x3D; 180 then</span><br><span class="line">		set description&#x3D;&#39;身材高挑&#39;;</span><br><span class="line">	elseif height &gt;&#x3D;170 and height&lt;180 then</span><br><span class="line">		set description&#x3D;&#39;标准身材&#39;;</span><br><span class="line">	else</span><br><span class="line">		set description&#x3D;&#39;一般身材&#39;;</span><br><span class="line">	end if;</span><br><span class="line">	</span><br><span class="line">	secect concat(&#39;身高&#39;, height, &#39;，对应的身材类型为：&#39;,description);</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>



<h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure produre_name( [in&#x2F;out&#x2F;inout] 参数名 参数类型)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">in : 该参数可以作为输入，也就是需要调用方传入值。（默认）</span><br><span class="line"></span><br><span class="line">out : 该参数作为输出，也就是该函数可以作为返回值。</span><br><span class="line"></span><br><span class="line">inout : 既可以作为输入函数，也可以作为输出函数。</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>in-输入</strong></li>
</ul>
<p>我们想把上面的身高信息成为一个可以传递的数值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test5(in height int)</span><br><span class="line">begin</span><br><span class="line">	declare description varchar(50) default &#39;&#39;;</span><br><span class="line">	</span><br><span class="line">	if height &gt;&#x3D; 180 then</span><br><span class="line">		set description&#x3D;&#39;身材高挑&#39;;</span><br><span class="line">	elseif height &gt;&#x3D;170 and height&lt;180 then</span><br><span class="line">		set description&#x3D;&#39;标准身材&#39;;</span><br><span class="line">	else</span><br><span class="line">		set description&#x3D;&#39;一般身材&#39;;</span><br><span class="line">	end if;</span><br><span class="line">	</span><br><span class="line">	secect concat(&#39;身高&#39;, height, &#39;，对应的身材类型为：&#39;,description);</span><br><span class="line">	</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>out-输出</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test6(in height int ,out description varchar(10))</span><br><span class="line">-- 输入身高，输出类型（varchar(10)是类型长度，可以不写）</span><br><span class="line">begin</span><br><span class="line">	if height &gt;&#x3D; 180 then</span><br><span class="line">		set description&#x3D;&#39;身材高挑&#39;;</span><br><span class="line">	elseif height &gt;&#x3D;170 and height&lt;180 then</span><br><span class="line">		set description&#x3D;&#39;标准身材&#39;;</span><br><span class="line">	else</span><br><span class="line">		set description&#x3D;&#39;一般身材&#39;;</span><br><span class="line">	end if;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>

<p>这个调用时用：<code>call pro_test6(188 , @description)</code></p>
<p>然后<code>select  @description</code> 就可以看到身材类型</p>
<p>小知识：</p>
<blockquote>
<p>@description ： 这种变量要在变量名称前加上 @ 符号。叫做<strong>用户会话变量</strong>，类似于全局变量一样）</p>
<p>@@global.sort_buffer_size：加上 @@ 符号的，叫做<strong>系统变量</strong></p>
</blockquote>
<h5 id="case结构"><a href="#case结构" class="headerlink" title="case结构"></a>case结构</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">case case_value</span><br><span class="line"></span><br><span class="line">	when when_value then ...	   -- 当值对应，执行后面的语句</span><br><span class="line">	when when_value then ...</span><br><span class="line">	[else ...]</span><br><span class="line">	</span><br><span class="line">end case;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">case </span><br><span class="line"></span><br><span class="line">	when 条件表达式 then ...			-- 表达式为真，执行后面的语句</span><br><span class="line">	when 条件表达式 then ...</span><br><span class="line">	[else ...]</span><br><span class="line">	</span><br><span class="line">end case;</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test7(mon int)</span><br><span class="line">begin</span><br><span class="line">	declare result varchar(10)			-- 声明变量接收结果</span><br><span class="line">	case</span><br><span class="line">		when mon&gt;&#x3D;1 and mon&lt;&#x3D;3 then</span><br><span class="line">			set result&#39;第一季度&#39;;</span><br><span class="line">		when mon&gt;&#x3D;4 and mon&lt;&#x3D;6 then</span><br><span class="line">			set result&#39;第二季度&#39;</span><br><span class="line">		when mon&gt;&#x3D;7 and mon&lt;&#x3D;9 then</span><br><span class="line">			set result&#39;第三季度&#39;</span><br><span class="line">		else</span><br><span class="line">			set result&#39;第四季度&#39;</span><br><span class="line"></span><br><span class="line">	end case;</span><br><span class="line">	select result(&#39;传递的月份为：&#39;,mon,&#39;，计算出的结果为&#39;,result) as content;</span><br><span class="line">	</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>



<h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>语法结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while search_condition do		-- search_condition成立就继续循环</span><br><span class="line">	语句</span><br><span class="line">end while;</span><br></pre></td></tr></table></figure>



<p>示例：（1加到n的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test8(n int)</span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">	declare total int default 0;</span><br><span class="line">	declare num int default 1;</span><br><span class="line">	while num&lt;&#x3D;n do</span><br><span class="line">		set total &#x3D; total + num;</span><br><span class="line">		set num &#x3D; num + 1;</span><br><span class="line">	end while;</span><br><span class="line">	select total;</span><br><span class="line"></span><br><span class="line">end$</span><br></pre></td></tr></table></figure>



<h5 id="repeat循环"><a href="#repeat循环" class="headerlink" title="repeat循环"></a>repeat循环</h5><p><strong>和while相反，它是满足条件退出循环</strong>（关注until的条件）</p>
<p>语法结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repeat</span><br><span class="line">	循环体</span><br><span class="line">	until search_condition			-- 直到满足search_condition条件，退出循环</span><br><span class="line">end repeat;</span><br></pre></td></tr></table></figure>



<p>示例：（1加到n的值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test9(n int)</span><br><span class="line">begin</span><br><span class="line">	declare total int default 0;</span><br><span class="line">	</span><br><span class="line">	repeat</span><br><span class="line">		set total &#x3D; total + n;</span><br><span class="line">		set n &#x3D; n-1;</span><br><span class="line">		until n&#x3D;0 					-- until 这里没有分号！</span><br><span class="line">	end repeat；</span><br><span class="line">	</span><br><span class="line">	select total;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>



<h5 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h5><p>退出循环的条件需要使用其他的语句定义，通常可以使用leave语句实现。语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[begin_label:] Loop</span><br><span class="line">	循环体</span><br><span class="line">end loop [end_label]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[begin_label:] ：这是用来声明loop循环的别名的。可忽略</span><br><span class="line">loop循环本身没有退出的条件</span><br></pre></td></tr></table></figure>

<p>如果不在循环体中增加退出循环的语句，那么loop语句可以用来实现简单的死循环</p>
<h5 id="leave语句"><a href="#leave语句" class="headerlink" title="leave语句"></a>leave语句</h5><p>用来从标注的流程构造中退出，通常和begin…end或者循环一起使用。</p>
<p>下面是一个使用loop循环和leave退出循环的简单例子：（1加到n）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test10(n int)</span><br><span class="line">begin</span><br><span class="line">	declare total int default 0;</span><br><span class="line">	</span><br><span class="line">	c:loop</span><br><span class="line">    	set total &#x3D; total + n;</span><br><span class="line">    	set n &#x3D; n-1;</span><br><span class="line">    	</span><br><span class="line">    	if n&lt;&#x3D; 0 then</span><br><span class="line">        	leave c;						-- 结束循环！</span><br><span class="line">        end if;</span><br><span class="line">        </span><br><span class="line">    end loop c;</span><br><span class="line">	</span><br><span class="line">	select total;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>



<h5 id="游标-光标"><a href="#游标-光标" class="headerlink" title="游标/光标"></a>游标/光标</h5><p>游标是用来存储查询结果集的数据类型，在存储过程和函数中可以使用光标对结果集进行循环的处理。</p>
<p>光标的使用包括光标的声明、open、fetch和close，其语法分别如下：</p>
<p>​    <strong>声明光标：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare cursor_name cursor for select_statement ;</span><br></pre></td></tr></table></figure>

<p>​    <strong>open光标：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open cursor_name;</span><br></pre></td></tr></table></figure>

<p>​    <strong>fetch光标：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fetch cursor_name into var_name [, var_name]...    -- 抓取游标的一行数据，会往下走</span><br></pre></td></tr></table></figure>

<p>​    <strong>close光标：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">close cursor_name ;</span><br></pre></td></tr></table></figure>



<p>查询emp表中数据，并逐行获取进行展示</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/8.png" alt="8"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test11()</span><br><span class="line">begin</span><br><span class="line">	declare e_id int(11),</span><br><span class="line">	declare e_name varchar(50),</span><br><span class="line">	declare e_age int(11),</span><br><span class="line">	declare e_salary int(11),</span><br><span class="line">	</span><br><span class="line">	declare emp_result cursor for select * from emp;	-- emp_result里面封装了查询emp表的结果集</span><br><span class="line">	</span><br><span class="line">	open emp_result;</span><br><span class="line">	</span><br><span class="line">	fetch emp_result into e_id,e_name,e_age,e_salary;</span><br><span class="line">	</span><br><span class="line">	select concat(&#39;id&#x3D;&#39;,e_id,&#39;,name&#x3D;&#39;,e_name,&#39;,age&#x3D;&#39;,e_age,&#39;,薪资为：&#39;,e_salary);</span><br><span class="line">	select concat(&#39;id&#x3D;&#39;,e_id,&#39;,name&#x3D;&#39;,e_name,&#39;,age&#x3D;&#39;,e_age,&#39;,薪资为：&#39;,e_salary);</span><br><span class="line">	</span><br><span class="line">	close emp_result;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>

<p>因为我们输出了两行select，所以可以得到金毛狮王和白眉鹰王的信息。比较繁琐，所以我们要用循环，并且解决无数据的报错问题</p>
<p>通过循环，获取游标中的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure pro_test12()</span><br><span class="line">begin</span><br><span class="line">	declare e_id int(11),</span><br><span class="line">	declare e_name varchar(50),</span><br><span class="line">	declare e_age int(11),</span><br><span class="line">	declare e_salary int(11),	</span><br><span class="line">	declare has_data int default 1;</span><br><span class="line">	</span><br><span class="line">	declare emp_result cursor for select * from emp; -- 声明光标</span><br><span class="line">	DECLARE EXIT HANDLER FOR NOT FOUND set has_data&#x3D;0;	-- 定义边界变量，mysql提供的机制</span><br><span class="line">	</span><br><span class="line">	open emp_result;</span><br><span class="line">	repeat</span><br><span class="line">		fetch emp_result into e_id,e_name,e_age,e_salary;</span><br><span class="line">		select concat(&#39;id&#x3D;&#39;,e_id,&#39;,name&#x3D;&#39;,e_name,&#39;,age&#x3D;&#39;,e_age,&#39;,薪资为：&#39;,e_salary);</span><br><span class="line">		until has_data &#x3D; 0;</span><br><span class="line">	</span><br><span class="line">	close emp_result;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>

<p>声明退出边界循环的这句话必须放在声明光标的后面。</p>
<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>（有返回值的函数）</p>
<p>语法结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cerate function function_name([param type...])</span><br><span class="line">returns type		-- 声明一个返回值的类型</span><br><span class="line">begin</span><br><span class="line">	...</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/9.png" alt="9"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 定义一个存储函数，获取满足条件(city)的总记录数。</span><br><span class="line"></span><br><span class="line">cerate function count_city(countryId int)</span><br><span class="line">returns int</span><br><span class="line">begin</span><br><span class="line">	declare cnum int</span><br><span class="line">	select count(*) into cnum from city where country_id&#x3D;countryId</span><br><span class="line">	return cnum;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>

<ul>
<li>用<code>select</code>调用存储函数。<code>count_city(1)        count_city(2)</code></li>
</ul>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>触发器是与表有关的数据库对象，指在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合。</p>
<p>触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作</p>
<p>MySQL的触发器<strong>只支持行级触发</strong>，不支持语句级触发。</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW和OLD的使用</th>
</tr>
</thead>
<tbody><tr>
<td>insert型触发器</td>
<td>new表示将要或已经新增的数据</td>
</tr>
<tr>
<td>update型触发器</td>
<td>old表示修改之前的数据，new表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>delete型触发器</td>
<td>old表示将要或已经删除的数据</td>
</tr>
</tbody></table>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>语法结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger trigger_name</span><br><span class="line"></span><br><span class="line">before&#x2F;after insert&#x2F;update&#x2F;delete</span><br><span class="line"></span><br><span class="line">on tbl_name</span><br><span class="line"></span><br><span class="line">[ for each row ] -- 行级触发器</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">trigger_stmt;	-- 触发的语句内容</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>



<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h4><p>需求：</p>
<blockquote>
<p>通过触发器记录emp表的数据变更日志，包含增加、更改、删除</p>
</blockquote>
<p>首先创建一张日志表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table emp_logs(</span><br><span class="line">	id int(11) not null auto_increment, </span><br><span class="line">    operation varchar(20) not null comment &#39;操作类型，insert&#x2F;update&#x2F;delete&#39;,</span><br><span class="line">    operate_time datetime not null comment &#39;操作时间&#39;,</span><br><span class="line">    operate_id int(11) not null comment &#39;操作表的ID&#39;,</span><br><span class="line">    operate_params varchar(500) comment &#39;操作参数&#39;,</span><br><span class="line">    primary key(&#96;id&#96;)</span><br><span class="line">)engine&#x3D;innodb default charset&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<p>创建insert型触发器，完成插入数据时的日志记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger emp_insert_trigger</span><br><span class="line">after insert</span><br><span class="line">on emp  		-- 对应emp表</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">	insert into emp_logs(id,operation, operate_time, operate_id, operate_params) values(null,&#39;insert&#39;,now(),new.id,concat(&#39;插入后（id：&#39;,new.id,&#39;,name:&#39;,new.name,&#39;,age:&#39;,new.age,&#39;,salary:&#39;,new.salary,&#39;）&#39;))</span><br><span class="line">	</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>

<p>创建update型触发器，完成插入数据时的日志记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger emp_update_trigger</span><br><span class="line">after update</span><br><span class="line">on emp  		-- 对应emp表</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">	insert into emp_logs(id,operation, operate_time, operate_id, operate_params) values(null,&#39;update&#39;,now(),new.id,concat(&#39;修改前（id：&#39;,old.id,&#39;,name:&#39;,old.name,&#39;,age:&#39;,old.age,&#39;,salary:&#39;,old.salary,&#39;）修改后（&#39;,new.id,&#39;,name:&#39;,new.name,&#39;,age:&#39;,new.age,&#39;,salary:&#39;,new.salary,&#39;）&#39;))</span><br><span class="line">	</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>

<p>创建update型触发器，完成插入数据时的日志记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger emp_delete_trigger</span><br><span class="line">after delete</span><br><span class="line">on emp  		-- 对应emp表</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">	insert into emp_logs(id,operation, operate_time, operate_id, operate_params) values(null,&#39;delete&#39;,now(),old.id,concat(&#39;插入后（id：&#39;,old.id,&#39;,name:&#39;,old.name,&#39;,age:&#39;,old.age,&#39;,salary:&#39;,old.salary,&#39;）&#39;))</span><br><span class="line">	</span><br><span class="line">end$</span><br></pre></td></tr></table></figure>



<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p>语法结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop trigger [schema_name.]trigger_name</span><br></pre></td></tr></table></figure>

<p>如果没有指定schema_name，默认为当前数据库</p>
<h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><p>可以通过执行show trigger 命令查看触发器的状态、语法等信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show trigger \G;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库优化全剖析（二）</title>
    <url>/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Mysql的体系结构概览"><a href="#Mysql的体系结构概览" class="headerlink" title="Mysql的体系结构概览"></a>Mysql的体系结构概览</h3><p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/1.jpg" alt="1"></p>
<blockquote>
<p>连接者：不同语言的代码程序和mysql的交互（SQL交互）</p>
</blockquote>
<p>整个MySQL Server由以下组成：</p>
<ul>
<li>Connection Pool：连接池组件<code>（管理、缓冲用户的连接，线程处理等需要缓存的需求）</code></li>
</ul>
<ul>
<li>Management Services &amp; Utilities：管理服务和工具组件<code>（系统管理和控制工具，例如备份恢复、Mysql复制、集群等）</code></li>
<li>SQL interface：SQL接口<code>（接受用户的SQL命令，并且返回用户需要查询的结果）</code></li>
<li>Parser：查询解析器<code>（SQL命令传递到解析器的时候会被解析器验证和解析(权限、语法结构) ）</code></li>
<li>Optimizer：查询优化器<code>（SQL语句在查询之前会使用查询优化器对查询进行优化）</code></li>
<li>Caches &amp; Buffers：缓存<code>（如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据）</code></li>
</ul>
<ul>
<li><p>Pluggable Storage Engines：插入式存储引擎</p>
<blockquote>
<p>存储引擎说白了就是如何管理操作数据（存储数据、如何更新、查询数据等）的一种<strong>方法</strong>。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型</p>
</blockquote>
</li>
</ul>
<ul>
<li>File System：文件系统</li>
</ul>
<p>​    和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。</p>
<p>​    这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h3 id="存储引擎概述"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述</h3><ul>
<li><p>和大多数数据库不同，MySQL中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎</p>
</li>
<li><p>存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式。</p>
</li>
<li><p>存储引擎是基于表的，而不是基于库的。所以存储引擎也成为表类型。</p>
</li>
</ul>
<ul>
<li>Oracle、SqlServer等数据库只有一种存储引擎。MySQL存在多种。</li>
<li>可以通过指令<code>show engines</code>，来查询当前数据库支持的存储引擎  </li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" alt="2"></p>
<ul>
<li>创建新表是如果不指定存储引擎，那么系统会使用默认的存储引擎。MySQL5.5之前的默认存储引擎是<code>MyISAM</code>，5.5之后就改为了<code>InnoDB</code>（default就是默认的引擎）</li>
</ul>
<h3 id="各种存储引擎特性"><a href="#各种存储引擎特性" class="headerlink" title="各种存储引擎特性"></a>各种存储引擎特性</h3><p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" alt="3"></p>
<p>（着重注意高亮的特性）</p>
<p>我们只需要重点了解<code>InnoDB和MyISAM</code>。另外两种MEMORY、MERGE了解即可。</p>
<h4 id="InnoDB特性"><a href="#InnoDB特性" class="headerlink" title="InnoDB特性"></a>InnoDB特性</h4><ul>
<li><p>InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。</p>
</li>
<li><p>但是对比MyISAM的存储引擎，InnoDB的处理效率差一点，并且会占用更多的磁盘空间以保留数据和索引。</p>
</li>
</ul>
<h5 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h5><h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><ol>
<li>使用共享表空间存储，这种方式创建的表结构保存在<code>.frm</code>文件中，数据和索引保存在<code>innodb_data_home_dir</code>和<code>innodb_data_file_path</code>定义的表空间中，可以是多个文件</li>
<li>使用多表空间存储，这种方式创建的表结构仍然存在<code>.frm</code>文件中，但是每个表的数据和索引单独保存在<code>.ibd</code>中</li>
</ol>
<h4 id="MyISAM特性"><a href="#MyISAM特性" class="headerlink" title="MyISAM特性"></a>MyISAM特性</h4><p>MyISAM不支持事务，也不支持外键，其优势是访问速度的快，对事务的完整性没有要求或者以select、insert为主的应用基本上都可以使用这个引擎来创建表，它有两个比较重要的特点：</p>
<h5 id="不支持事务"><a href="#不支持事务" class="headerlink" title="不支持事务"></a>不支持事务</h5><h5 id="文件存储方式"><a href="#文件存储方式" class="headerlink" title="文件存储方式"></a>文件存储方式</h5><p>每个MyISAM在磁盘上存储成三个文件，其文件名都和表名相同，但扩展名分别是：</p>
<p><code>.frm</code>（存储表定义）</p>
<p><code>.myd</code>（MyData，存储数据）</p>
<p><code>.myi</code>（MyIndex，存储索引）</p>
<h4 id="MEMORY特性"><a href="#MEMORY特性" class="headerlink" title="MEMORY特性"></a>MEMORY特性</h4><p>（memory——内存）</p>
<ul>
<li><p>​    Memory存储引擎将表的数据存放在内存中。每个表对应一个磁盘文件，格式是.frm，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。</p>
</li>
<li><p>​    Memory类型的表访问非常的快，因为它的数据是存放在内存中的，并且默认使用Hash索引，但是服务一旦关闭，表中的数据就会丢失。（安全没有保障）</p>
</li>
</ul>
<h4 id="MERGE特性"><a href="#MERGE特性" class="headerlink" title="MERGE特性"></a>MERGE特性</h4><ul>
<li><p>Merge存储引擎是一组MyISAM表的组合。</p>
</li>
<li><p>Merge表本身没有存储数据，对Merge类型的表进行查询更新删除操作，实际上是对内部的MyISAM表进行的。</p>
</li>
<li><p>可以对Merge表进行drop操作，但是这个操作只是删除Merge表的定义，对内部的表是没有任何影响的。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" alt="4"></p>
<h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>以下是几种常用的存储引擎的使用环境：</p>
<ul>
<li><p>InnoDB：</p>
<p>​    是MySQL的默认引擎。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。    </p>
<p>​    InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定，还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择</p>
</li>
</ul>
<ul>
<li><p>MyISAM：</p>
<p>​    如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么这个存储引擎是非常合适的</p>
</li>
</ul>
<ul>
<li><p>MEMORY：</p>
<p>​    将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。Memory的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。</p>
<p>​    Memory表通常用于更新不太频繁的小表，用以快速得到访问结果。</p>
</li>
</ul>
<ul>
<li><p>MERGE：</p>
<p>​    用于将一系列等同的Myisam表以逻辑方式组合在一起，并作为一个对象引用他们。merge表的优势在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善Merge表的访问效率。这对于存储数据诸如数据仓库等VLDB环境十分合适。</p>
</li>
</ul>
<h1 id="优化SQL步骤"><a href="#优化SQL步骤" class="headerlink" title="优化SQL步骤"></a>优化SQL步骤</h1><p>开发初期数据量小，开发人员写SQL语句更重视功能上的实现，应用上线后，随着生产数据量的急剧增长，很多SQL语句开始逐渐显露出性能问题。    因此我们要对它们进行优化。</p>
<p>当面对一个有SQL性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题SQL并尽快解决问题。</p>
<h3 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h3><p><code>show status</code>命令可以提供服务器状态信息。 （很多)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 当前连接的信息</span><br><span class="line">show status like &#39;Com_______&#39;;			-- 7个_符号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询全局的信息</span><br><span class="line">show global status like &#39;Com_______&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" alt="5"></p>
<ul>
<li>可以看出这个数据库是查询为主，还是插入为主。提供了一些<strong>借鉴性指标</strong>。</li>
</ul>
<h5 id="查看Innodb引擎在进行增删改查影响的行数"><a href="#查看Innodb引擎在进行增删改查影响的行数" class="headerlink" title="查看Innodb引擎在进行增删改查影响的行数"></a>查看Innodb引擎在进行增删改查影响的行数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询innodb引擎全局的信息</span><br><span class="line">show global status like &#39;Innodb_rows_%&#39;;</span><br></pre></td></tr></table></figure>





<h3 id="定位低效率执行SQL"><a href="#定位低效率执行SQL" class="headerlink" title="定位低效率执行SQL"></a>定位低效率执行SQL</h3><p>可以通过以下两种方式定位执行效率低的SQL语句：</p>
<ol>
<li><strong>慢查询日志</strong>：通过慢查询日志定位。用<code>--log-slow-queries[=file_name]</code> 选项启动时，mysqld写一个包含所有执行时间超过<code>--long_query_time</code>秒的SQL语句的日志文件。（后面详细讲解）</li>
<li><strong>show processlist</strong>：慢查询日志在查询结束后才记录，所以在应用反映执行效率出现问题的时候并不能定位问题，可以使用<code>show procseelist</code>命令查看当前MySQL在进行的进程，包括线程的状态、是否锁表等，可以<strong>实时地</strong>查看SQL的执行情况，同时对一些锁表操作进行优化。</li>
</ol>
<p>show processlist的示例：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" alt="6"></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/7.png" alt="7"></p>
<h3 id="explain分析执行计划"><a href="#explain分析执行计划" class="headerlink" title="explain分析执行计划"></a>explain分析执行计划</h3><p>​    通过以上步骤查询到效率低的SQL语句后，可以通过<code>explain</code>或者<code>desc</code>命令获取MySQL如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接的顺序。</p>
<ul>
<li>在任何的select语句之前加入explain，就可以输出对应的查询计划。</li>
</ul>
<p>查询SQL语句的执行计划：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from tb_item where id &#x3D; 1;			-- tb_item是有三百万数据的表</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/8.png" alt="8"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from tb_item where title &#x3D; &#39;阿尔卡特（OT-979） 冰川白 联通3G手机3&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/9.png" alt="9"></p>
<p>表头信息的含义：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，是一组数字，表示查询中操作表的顺序</td>
</tr>
<tr>
<td>select_type</td>
<td>表示select的类型，常见的取值有simple（简单表，即不使用表连接或子查询），primary（主查询，即外层的查询），union（union中的第二个或者后面的查询语句）、subquery（子查询中的第一个select）等</td>
</tr>
<tr>
<td>table</td>
<td>输出结果的表</td>
</tr>
<tr>
<td>type</td>
<td>表的连接类型</td>
</tr>
<tr>
<td>possible_key</td>
<td>表示查询时，可能使用的索引</td>
</tr>
<tr>
<td>key</td>
<td>表示实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>索引字段的长度</td>
</tr>
<tr>
<td>rows</td>
<td>扫描行的数量</td>
</tr>
<tr>
<td>extra</td>
<td>执行情况的说明和描述</td>
</tr>
</tbody></table>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>创建表，然后再往表结构中插入几条测试记录</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/10.png" alt="10"></p>
<p>角色表、用户表、用户角色表（中间表）。</p>
<p>插入用户的测试数据、角色的测试数据，再插入关系表中的数据。</p>
<p><strong>用户表：</strong></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/11.png" alt="11"></p>
<p><strong>角色表：</strong></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/12.png" alt="12"></p>
<p><strong>用户角色的关系表：</strong></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/13.png" alt="13"></p>
<h4 id="explain之id"><a href="#explain之id" class="headerlink" title="explain之id"></a>explain之id</h4><p><strong>id字段是select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</strong></p>
<p>（如果是单表操作，意义不大）</p>
<p>id情况有三种：</p>
<ol>
<li><p>id相同表示加载表的顺序是从上到下。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/14.png" alt="14"></p>
</li>
<li><p>id不同。id值越大，优先级越高，越先被执行。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/15.png" alt="15"></p>
</li>
<li><p>id有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下执行；在所有的组中，id值越大，优先级越高，越先执行。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/16.png" alt="16"></p>
</li>
</ol>
<h4 id="explain之select-type"><a href="#explain之select-type" class="headerlink" title="explain之select_type"></a>explain之select_type</h4><p>表示select的类型，常见的取值如下图所示：</p>
<table>
<thead>
<tr>
<th>select_type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>simple</td>
<td>简单的select查询，查询中不会包含子查询或者UNION</td>
</tr>
<tr>
<td>primary</td>
<td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td>
</tr>
<tr>
<td>subquery （子查询）</td>
<td>在select或where列表中包含了子查询</td>
</tr>
<tr>
<td>derived</td>
<td>在from列表中包含的子查询，被标记为derived（衍生）MySQL会递归执行这些子查询，把结果放在临时表中（套娃出现的临时表）</td>
</tr>
<tr>
<td>union      （并集）</td>
<td>若第二个select出现在union之后，则标记为union；若union包含在from子句的子查询中，外层select将被标记为：derived</td>
</tr>
<tr>
<td>union result</td>
<td>从union表获取结果的select</td>
</tr>
</tbody></table>
<ul>
<li>从上到下效率越来越低。</li>
</ul>
<h4 id="explain之table"><a href="#explain之table" class="headerlink" title="explain之table"></a>explain之table</h4><p>展示这一行的数据是关于哪一张表的。</p>
<h4 id="explain之type"><a href="#explain之type" class="headerlink" title="explain之type"></a>explain之type</h4><p>type显示的是访问类型，是较为重要的一个指标，可取值为：</p>
<p>（大概知道SQL语句执行效率的情况）</p>
<table>
<thead>
<tr>
<th>type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>MySQL不访问任何表，索引，直接返回结果</td>
</tr>
<tr>
<td>system</td>
<td>表只有一行记录（等于系统表），这是const类型的特例，一般不会出现</td>
</tr>
<tr>
<td>const</td>
<td>表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。</td>
</tr>
<tr>
<td>eq_ref</td>
<td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td>
</tr>
<tr>
<td>ref</td>
<td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多行）</td>
</tr>
<tr>
<td>range</td>
<td>只检索给定返回的行，使用一个索引来选择行。where之后出现between，&lt;，&gt;，in等操作</td>
</tr>
<tr>
<td>index</td>
<td>index与all的区别为index类型只是遍历了索引树，通常比all快</td>
</tr>
<tr>
<td>all</td>
<td>将遍历全表以找到匹配的行</td>
</tr>
</tbody></table>
<ul>
<li><p>结果值由上到下，从好到坏。</p>
</li>
<li><p><strong>一般来说，我们至少要保证查询至少达到range级别，最好达到ref</strong></p>
</li>
</ul>
<h4 id="explain之key"><a href="#explain之key" class="headerlink" title="explain之key"></a>explain之key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">possible_keys：显示可能应用在这张表的索引，一个或多个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key：实际使用的索引，如果为NULL，则没有使用索引。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key_len：表示索引中使用的字节数，该值为索引字段**最大可能长度**，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</span><br></pre></td></tr></table></figure>

<ul>
<li>要是发现没有索引就要注意检查了</li>
</ul>
<h4 id="explain之rows"><a href="#explain之rows" class="headerlink" title="explain之rows"></a>explain之rows</h4><p>扫描的行的数量。</p>
<p>（有索引扫描一行，无索引整表查询）</p>
<h4 id="explain之extra"><a href="#explain之extra" class="headerlink" title="explain之extra"></a>explain之extra</h4><p>其他的额外的执行计划信息，在该列展示：</p>
<table>
<thead>
<tr>
<th>extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>using filesort</td>
<td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引进行读取，称为“文件排序”</td>
</tr>
<tr>
<td>using temporary</td>
<td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于order和group by</td>
</tr>
<tr>
<td>using index</td>
<td>表示相应的select操作使用了覆盖索引，避免访问表的数据行，效率不错</td>
</tr>
</tbody></table>
<ul>
<li>前面两个非常耗性能，出现了要考虑优化</li>
</ul>
<h3 id="show-profile分析SQL"><a href="#show-profile分析SQL" class="headerlink" title="show profile分析SQL"></a>show profile分析SQL</h3><p>MySQL从5.0.37版本开始增加了<code>show profile</code>和<code>show profiles</code>语句的支持。</p>
<p><code>show profiles</code>能够在做SQL优化时帮助我们<strong>了解时间都耗费哪里去了</strong></p>
<ul>
<li>通过have_profiling参数，能够看到当前Mysql是否支持profile：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@have_profiling		-- 会打印yes或者no</span><br></pre></td></tr></table></figure>

<ul>
<li>默认profiling是关闭的，可以通过set语句在Session级别开启：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@profiling -- 可以看到是否开启。0关闭、1开启</span><br><span class="line"></span><br><span class="line">set profiling &#x3D; 1; -- 设为1开启profiling开关。</span><br></pre></td></tr></table></figure>



<ul>
<li>show profiles可以看到我们之前所有操作的耗时</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/17.png" alt="17"></p>
<ul>
<li>通过<code>show profile for query Query_id</code>，可以查看到该SQL语句执行过程中每个线程的状态和消耗的时间。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/18.png" alt="18"></p>
<blockquote>
<p>TIP：</p>
<p>​        Sending data 状态表示MySQL线程<strong>开始访问数据行并把结果返回给客户端的过程</strong>，而不仅仅是返回个客户端。    由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整个查询中耗时最长的状态。</p>
</blockquote>
<ul>
<li>在获取到最消耗时间的线程状态后，MySQL支持进一步选择<code>all</code>、<code>cpu</code>、<code>block io</code>、<code>context switch</code>、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。</li>
</ul>
<p>例如，我们查看这条语句的cpu：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/19.png" alt="19"></p>
<h3 id="trace分析优化器执行计划"><a href="#trace分析优化器执行计划" class="headerlink" title="trace分析优化器执行计划"></a>trace分析优化器执行计划</h3><p>MySQL5.6提供了对SQL的跟踪trace，通过trace文件能够进一步了解为什么优化器选择A计划，而不是选择B计划。</p>
<ul>
<li>打开trace，设置格式为JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set optimizer_trace &#x3D; &quot;enabled&#x3D;on&quot;,end_markers_in_json&#x3D;on;	-- 开启trace</span><br><span class="line">set optimizer_trace_max_mem_size &#x3D; 1000000;   			-- 设置内存大小</span><br></pre></td></tr></table></figure>



<ul>
<li>执行SQL语句（例如执行tb_item表的id前三个）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_item where id &lt; 4;				-- 这是一个普通的例子</span><br></pre></td></tr></table></figure>



<ul>
<li>最后检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure>







<h1 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h1><p>索引是数据库优化最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的MySQL性能问题。</p>
<h3 id="验证索引提升查询效率"><a href="#验证索引提升查询效率" class="headerlink" title="验证索引提升查询效率"></a>验证索引提升查询效率</h3><p>在我们准备的表结构tb_item中，一共存储了300万条记录</p>
<ul>
<li>根据ID查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_item where id &#x3D; 1999 \G;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/20.png" alt="20"></p>
<p>根据ID查询速度非常快，因为id为<strong>主键，有索引</strong>。</p>
<ul>
<li>根据title进行精确查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_item where title&#x3D;&#39;iphoneX 移动3G 32G941&#39;\G;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/21.png" alt="21"></p>
<ul>
<li>处理方案，针对title字段，创建索引：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_item_title on tb_item(title);</span><br></pre></td></tr></table></figure>

<p>可能耗费多的时间（51.51sec），数据库底层正在重建索引</p>
<ul>
<li>索引创建完成后，再次进行查询：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_item where title&#x3D;&#39;三星 Note II （N7100） 云石白 联通3G手机8&#39;\G;</span><br></pre></td></tr></table></figure>

<p>这时的执行效率为0.01s，瞬间提速！</p>
<h3 id="索引的使用-1"><a href="#索引的使用-1" class="headerlink" title="索引的使用"></a>索引的使用</h3><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/22.png" alt="22"></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/23.png" alt="23"></p>
<p>对name、status、address三个字段创建了索引。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/24.png" alt="24"></p>
<h4 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h4><h5 id="1-全值匹配，对索引中所有列都指定具体值。"><a href="#1-全值匹配，对索引中所有列都指定具体值。" class="headerlink" title="1).    全值匹配，对索引中所有列都指定具体值。"></a>1).    <strong>全值匹配</strong>，对索引中所有列都指定具体值。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from tb_seller where name&#x3D;&#39;小米科技&#39; and status&#x3D;&#39;1&#39; and address&#x3D;&#39;西安市&#39; \G;</span><br></pre></td></tr></table></figure>

<p>explain查看执行计划。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/25.png" alt="25"></p>
<h5 id="2-最左前缀法则"><a href="#2-最左前缀法则" class="headerlink" title="2).    最左前缀法则"></a>2).    <strong>最左前缀法则</strong></h5><p>如果索引了多列，要遵守最左前缀法则。<strong>指的是查询从索引的最左前列开始，并且不跳过索引中的列。</strong></p>
<blockquote>
<p>根据我们的索引，查询要包含最左的name，并且不能跳过status直接跨到address来。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/26.png" alt="26"></p>
<p>和where后面的顺序无关，<code>status and address and name</code> 那也是走索引的。</p>
<ul>
<li>如果不遵守最左前缀法则，就不会走索引。</li>
</ul>
<ul>
<li>我们发现，我们跳过中间的status也会走索引。但是因为违反最左前缀法则，实际上只走了name的索引，而address的索引是失效的。</li>
</ul>
<h5 id="3-范围查询右边的列，不能使用索引"><a href="#3-范围查询右边的列，不能使用索引" class="headerlink" title="3).    范围查询右边的列，不能使用索引"></a>3).    <strong>范围查询右边的列，不能使用索引</strong></h5><ul>
<li>之前我们都是使用<strong>精确匹配</strong>，如果我们把<code>status=&#39;1&#39;</code>改为<code>status&gt;&#39;1&#39;</code>，status就变成了范围查询</li>
<li>当status使用的范围查询后，它右边的address就不能使用索引了。</li>
</ul>
<p>（要注意避免这种情况）</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/27.png" alt="27"></p>
<h5 id="4-不要在索引列上进行运算操作，索引将失效"><a href="#4-不要在索引列上进行运算操作，索引将失效" class="headerlink" title="4).    不要在索引列上进行运算操作，索引将失效"></a>4).    <strong>不要在索引列上进行运算操作，索引将失效</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_seller where substring(name,3,2) &#x3D; &#39;科技&#39;;</span><br><span class="line"></span><br><span class="line">-- 这是查询name中，第三个字符开始截取两个字符，这两个字符为‘科技’的匹配项</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/28.png" alt="28"></p>
<p>这是不使用索引的。</p>
<h5 id="5-字符串不加单引号，造成索引失效"><a href="#5-字符串不加单引号，造成索引失效" class="headerlink" title="5).    字符串不加单引号，造成索引失效"></a>5).    <strong>字符串不加单引号，造成索引失效</strong></h5><p>虽然写不写单引号都能查询到对应数据（仅对应数字），但是不写索引就会失效。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/29.png" alt="29"></p>
<h5 id="6-尽量使用覆盖索引，避免select"><a href="#6-尽量使用覆盖索引，避免select" class="headerlink" title="6).    尽量使用覆盖索引，避免select*"></a>6).    <strong>尽量使用覆盖索引，避免select*</strong></h5><p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select*</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/30.png" alt="30"></p>
<p>我们发现不使用select*，Extra变了。</p>
<ul>
<li>如果查询列，超出索引列，也会降低性能（就是查了没有索引的password）</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/31.png" alt="31"></p>
<p>因为所有没有password，所以要回表查询。</p>
<blockquote>
<p>TIP：</p>
<p><strong>using index</strong>：使用覆盖索引的时候就会出现</p>
<p><strong>using where</strong>：在查找使用索引的情况下，需要回表去查询所需的数据</p>
<p><strong>using index condition</strong>：查找使用了索引，但是需要回表查询数据</p>
<p><strong>using index ; using where</strong>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p>
</blockquote>
<ul>
<li>所以使用覆盖查询，避免回表查询</li>
</ul>
<h5 id="7-用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会用到"><a href="#7-用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会用到" class="headerlink" title="7).    用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会用到"></a>7).    <strong>用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会用到</strong></h5><p>示例：name是索引列，而createtime不是索引列，中间是or进行连接是不走索引的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from tb_seller where name&#x3D;&#39;黑马程序员&#39; or createtime&#x3D;&#39;2088-01-01 12:00:00&#39; \G;</span><br></pre></td></tr></table></figure>

<ul>
<li>整段索引都失效！</li>
</ul>
<h5 id="8-以-开头的Like模糊查询，索引失效"><a href="#8-以-开头的Like模糊查询，索引失效" class="headerlink" title="8).    以%开头的Like模糊查询，索引失效"></a>8).    <strong>以%开头的Like模糊查询，索引失效</strong></h5><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_seller where name like &#39;科技%&#39;;</span><br><span class="line">-- 我们查询的内容是以科技开始的，索引是生效的</span><br><span class="line"></span><br><span class="line">select * from tb_seller where name like &#39;%科技&#39;;</span><br><span class="line">-- 我们查询的内容是以科技结尾的，索引失效</span><br><span class="line"></span><br><span class="line">&#39;%科技%&#39;	-- 这样也是索引失效</span><br></pre></td></tr></table></figure>

<ul>
<li>只要是模糊匹配，%加在了前面，索引失效</li>
</ul>
<p>这个问题我们可以用覆盖索引来解决这类问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sellerid from tb_seller where name like &#39;%科技%&#39;;</span><br><span class="line">-- 使用覆盖索引，而不是select*，就会使用索引了</span><br><span class="line"></span><br><span class="line">-- 模糊匹配，查询的列包含不是索引的列，索引直接失效！！</span><br></pre></td></tr></table></figure>





<h5 id="9-如果MySQL评估使用索引比全表更慢，则不使用索引"><a href="#9-如果MySQL评估使用索引比全表更慢，则不使用索引" class="headerlink" title="9).    如果MySQL评估使用索引比全表更慢，则不使用索引"></a>9).    <strong>如果MySQL评估使用索引比全表更慢，则不使用索引</strong></h5><p>如果我只查address的索引，但是不符合最左前缀原则，不走索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_seller where address&#x3D;&#39;北京市&#39;;</span><br></pre></td></tr></table></figure>



<p>我们要单独为address建立索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_seller_address on tb_seller(address)</span><br></pre></td></tr></table></figure>



<p>我们再测试查找address的索引：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/32.png" alt="32"></p>
<ul>
<li>发现虽然有索引，但实际并没有走索引。</li>
</ul>
<p>再测试西安市的地址查询：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/33.png" alt="33"></p>
<ul>
<li>走索引了！    同样一条SQL语句，为什么会有两种扫描方式？</li>
</ul>
<p>​    这是因为MySQL的底层的执行器在解析执行计划的时候，发现12条数据11条都是北京市，还不如全表扫描走得快，就放弃索引了。</p>
<h5 id="10-is-NULL-，-is-NOT-NULL-有时-索引失效"><a href="#10-is-NULL-，-is-NOT-NULL-有时-索引失效" class="headerlink" title="10).    is NULL ， is NOT NULL  有时 索引失效"></a>10).    is NULL ， is NOT NULL  有时 索引失效</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_seller where address is null;	-- 查询address列中为空的</span><br><span class="line"></span><br><span class="line">select * from tb_seller where address is not null;	-- 查询address列中不为空的</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们发现，在这里<code>is null</code>走了索引。<code>is not null</code>没有走索引。</p>
<p>​    这个和上一个差不多意思，因为空的没有或者比较少，所以就通过索引来找。非空占了大部分，就还不如走全表扫描</p>
</li>
</ul>
<h5 id="11-in走索引，not-in索引失效"><a href="#11-in走索引，not-in索引失效" class="headerlink" title="11).    in走索引，not in索引失效"></a>11).    in走索引，not in索引失效</h5><p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/34.png" alt="34"></p>
<ul>
<li>编写时尽量使用<code>in</code>，别使用<code>not in</code></li>
</ul>
<h5 id="12-单列索引和复合索引"><a href="#12-单列索引和复合索引" class="headerlink" title="12).    单列索引和复合索引"></a>12).    单列索引和复合索引</h5><p>​    结论：尽量使用复合索引，而少使用单列索引。</p>
<p>​    当我们创建了三个单列索引的时候，我们进行多字段搜索的时候，它只会使用一个索引。而这个索引，是数据库底层选择的最优的索引。</p>
<p>（最优的方法也基本是之前的思路，看占比）</p>
<h3 id="查看索引使用情况"><a href="#查看索引使用情况" class="headerlink" title="查看索引使用情况"></a>查看索引使用情况</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Handler_read%&#39;;</span><br><span class="line"></span><br><span class="line">show global status like &#39;Handler_read%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/35.png" alt="35"></p>
<p>这些指标的意思不作重点掌握，自己了解即可。</p>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><p>环境准备：</p>
<p>创建两张表，<code>tb_user_1</code> 和<code>tb_user_2</code></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/36.png" alt="36"></p>
<p>往这两张表中分别导入100万条记录。</p>
<p>当使用<code>load</code>命令导入数据的时候，适当的设置可以提高导入的效率。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/37.png" alt="37"></p>
<p>对于InnoDB类型的表，有以下几种方式可以提高导入的效率：</p>
<h5 id="1）主键顺序插入"><a href="#1）主键顺序插入" class="headerlink" title="1）主键顺序插入"></a>1）主键顺序插入</h5><p>​    因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。</p>
<p>​    如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入的效率。</p>
<blockquote>
<p>脚本文件介绍：</p>
<p>​            sql1.log   ——→    主键有序</p>
<p>​            sql2.log   ——→    主键无序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data local infile&#39;&#x2F;root&#x2F;sql1.log&#39; in table &#39;tb_user_1&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;		-- 有序的（19.37sec）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">load data local infile&#39;&#x2F;root&#x2F;sql2.log&#39; in table &#39;tb_user_1&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;		-- 无序的（1min 51.42sec）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 还要标明文件中：	域以&#39;,&#39;分隔。  行以&#39;\n&#39;就是回车分隔</span><br></pre></td></tr></table></figure>





<h5 id="2）关闭唯一性校验"><a href="#2）关闭唯一性校验" class="headerlink" title="2）关闭唯一性校验"></a>2）关闭唯一性校验</h5><p>在导入数据前执行<code>SET UNIQUE_CHECKS=0</code>，关闭唯一性校验，在导入结束后执行<code>SET UNIQUE_CHECKS=1</code>，恢复唯一性校验，可以提高导入的效率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET UNIQUE_CHECKS&#x3D;0	-- 关闭</span><br><span class="line"></span><br><span class="line">	-- 导入成功后</span><br><span class="line"></span><br><span class="line">SET UNIQUE_CHECKS&#x3D;1	-- 开启</span><br></pre></td></tr></table></figure>





<h5 id="3）手动提交事务"><a href="#3）手动提交事务" class="headerlink" title="3）手动提交事务"></a>3）手动提交事务</h5><p>如果应用使用自动提交的方式，建议在导入前执行<code>SET AUTOCOMMIT=0</code>，关闭自动提交，导入结束后再执行 <code>SET AUTOCOMMIT=1</code>，打开自动提交，也可以提高导入了效率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT&#x3D;0	-- 关闭</span><br><span class="line"></span><br><span class="line">	-- 导入成功后</span><br><span class="line"></span><br><span class="line">SET AUTOCOMMIT&#x3D;1	-- 开启</span><br></pre></td></tr></table></figure>







<h3 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h3><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p>
<ul>
<li><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句。</p>
<p>这种方式将大大的缩减客户端与数据库的连接，关闭等消耗。</p>
</li>
</ul>
<p>原始方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br></pre></td></tr></table></figure>

<p>优化后的方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;);</span><br></pre></td></tr></table></figure>





<ul>
<li>在事务中进行数据插入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction;		</span><br><span class="line"></span><br><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line"></span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>





<ul>
<li>数据有序插入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into tb_test values(4,&#39;Tim&#39;);</span><br><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line"></span><br><span class="line">-- 优化后</span><br><span class="line">insert into tb_test values(1,&#39;Tom&#39;);</span><br><span class="line">insert into tb_test values(2,&#39;Cat&#39;);</span><br><span class="line">insert into tb_test values(3,&#39;Jerry&#39;);</span><br><span class="line">insert into tb_test values(4,&#39;Tim&#39;);</span><br></pre></td></tr></table></figure>





<h3 id="优化order-by语句"><a href="#优化order-by语句" class="headerlink" title="优化order by语句"></a>优化order by语句</h3><p>order by为排序表达式，用于指定排序的依据，它可以是字段名也可以是字段别名（默认升序）</p>
<h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/C:%5CUsers%5C%E7%BC%98%E8%B5%B7%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1593406080601.png" alt="1593406080601"></p>
<p>创建表，插入数据，创建复合索引</p>
<h4 id="两种排序方式"><a href="#两种排序方式" class="headerlink" title="两种排序方式"></a>两种排序方式</h4><p>1).    第一种是通过对返回数据进行排序，也就是通常说的filesort排序，所有不是通过索引直接返回排序结果的排序都叫<code>FileSort</code>排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age;			<span class="comment">-- 升序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;	<span class="comment">-- 降序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单字段升降序，多字段升降序，都不会使用索引（效率低）</span></span><br></pre></td></tr></table></figure>



<p>2).    第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高（使用覆盖索引）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age;	<span class="comment">-- id是有索引的，这样就会使用到索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果select id,age,salary,name。` 但是name没有索引，就不会使用索引了</span></span><br></pre></td></tr></table></figure>



<p><strong>多字段排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,age,salary from emp order by age,salary;		-- 根据age和salary排序</span><br></pre></td></tr></table></figure>

<ol>
<li>如果两个条件一个升序<code>age asc</code>，一个降序<code>salary desc</code>，就会出现using filesort。尽量避免！</li>
<li>多字段排序的顺序需要和索引的<strong>顺序保持一致</strong></li>
</ol>
<blockquote>
<p>尽量减少额外的排序，通过索引直接返回有序数据。where条件和Order by使用相同的索引，并且Order by的顺序和索引的顺序相同，并且Order by的字段都是升序或者都是降序。</p>
</blockquote>
<h4 id="Filesort的优化"><a href="#Filesort的优化" class="headerlink" title="Filesort的优化"></a>Filesort的优化</h4><p>​    通过创建合适的索引，能减少Filesort的出现，但是在某些情况下，条件限制不能让Filesort消失，那么就需要加快Filesort的操作。</p>
<p>​    对于Filesort，MySQL有两种排序算法：</p>
<ul>
<li><strong>两次扫描算法：</strong>MySQL4.1之前使用这个。首先根据<strong>排序字段和行指针</strong>在sort buffer中排序，完成排序后，拿着<strong>行指针回表读取记录</strong>。（该操作可能会导致大量的I/O操作，性能不好）</li>
</ul>
<ul>
<li><strong>一次扫描算法：</strong>一次性取出所有满足条件的字段，然后再排序区sort buffer中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要搞。 </li>
</ul>
<p>​    MySQL通过比较系统变量<code>max_length_for_sort_data</code>的大小和<code>Query语句</code>取出字段的大小，来判定用哪一种排序算法，如果max_length_for_sort_data更大，那么使用第二种优化之后的算法；否则使用第一种。</p>
<p>​    可以适量<strong>提高</strong><code>sort_buffer_size</code>和<code>max_length_for_sort_data</code>系统变量，来增大排序区的大小，提高排序的效率。</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%85%A8%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/38.png" alt="38"></p>
<h4 id="优化group-by语句"><a href="#优化group-by语句" class="headerlink" title="优化group by语句"></a>优化group by语句</h4><p>由于group by实际上也同样会进行排序操作，而且与order by相比，group by主要只是多了排序之后的分组操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select age,count(*) from emp group by age;</span><br><span class="line">-- 对于age列，count列计数，进行age的排序。 </span><br><span class="line"></span><br><span class="line">-- Using temporary;Using filesort</span><br></pre></td></tr></table></figure>



<ul>
<li>在by age后面加上<code>order by null</code>，只分组不排序，加快效率</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select age,count(*) from emp group by age order by null;</span><br><span class="line">-- Using temporary</span><br></pre></td></tr></table></figure>

<ul>
<li>然后我们可以<strong>创建索引</strong>提高效率，就可以Using index了</li>
</ul>
<h4 id="优化嵌套查询（子查询）"><a href="#优化嵌套查询（子查询）" class="headerlink" title="优化嵌套查询（子查询）"></a>优化嵌套查询（子查询）</h4><p>Mysql4.1版本之后，开始支持SQL的子查询。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p>
<p>我们之前有角色表，用户表，用户角色中间表三个表。</p>
<p>示例，查找有角色的所有的用户信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from t_user where id in (select user_id from user_role);</span><br><span class="line">-- 我们在user_role这张表中能查到用户id，再根据这个用户id查询对应的用户信息。</span><br></pre></td></tr></table></figure>



<p>使用多表联查替换子查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from t_user u , user_role ur where u.id&#x3D;ur.user_id;</span><br></pre></td></tr></table></figure>







<h4 id="优化or条件"><a href="#优化or条件" class="headerlink" title="优化or条件"></a>优化or条件</h4><p>对于包含or的查询子句，如果要利用索引，则or之间的每个条件列都必须用到索引，而且<strong>不能使用到复合索引</strong>；如果没有索引，则应该考虑增加索引</p>
<blockquote>
<p>不能复合索引是指：or 两边的列不能同是一个复合索引。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">or</span> age=<span class="number">30</span>;</span><br></pre></td></tr></table></figure>



<p>但是！！建议使用union（并集）替换or：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select*from emp where id&#x3D;1 union select*from emp where id&#x3D;10;</span><br></pre></td></tr></table></figure>





<h4 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h4><blockquote>
<p>limit 10：查询第一页，10条记录</p>
<p>limit 10,10：查询第二页，10条记录</p>
<p>limit 20,10</p>
</blockquote>
<p>​    一般分页查询时，通过创建覆盖索引能够比较好地提高性能。</p>
<p>​    一个常见又非常头疼的问题<code>limit 2000000,10</code>，此时需要MySQL排序前2000010记录，却仅仅返回2000000-2000010的记录，其他记录丢失，查询排序的代价很大。</p>
<h5 id="优化思路一"><a href="#优化思路一" class="headerlink" title="优化思路一"></a>优化思路一</h5><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_item <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item t , (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">form</span> tb_item <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id = a.id;</span><br></pre></td></tr></table></figure>



<h5 id="优化思路二"><a href="#优化思路二" class="headerlink" title="优化思路二"></a>优化思路二</h5><p>该方案<strong>仅适用于主键自增的表</strong>，可以把Limit查询转换成某个位置的查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2000000</span> <span class="keyword">limit</span> <span class="number">10</span>;	<span class="comment">-- id走索引了，贼快</span></span><br></pre></td></tr></table></figure>

<p>（主键自增，还不能出现断层）</p>
<h3 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h3><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化的目的。</p>
<h4 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h4><p>在查询语句中<strong>表名的后面</strong>，添加use index来提供希望MySQL去参考的索引列表，可以让MySQL不在考虑其他可用的索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">						<span class="comment">-- 表中有name的单列索引和复合索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;		</span><br><span class="line"><span class="comment">-- 使用了单列索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">use</span> <span class="keyword">index</span>(idx_seller_name_status) <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>; 		<span class="comment">-- 使用了我们指定的复合索引</span></span><br></pre></td></tr></table></figure>



<h4 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h4><p>ignore index和use index 恰恰<strong>相反</strong>，也是写在表名的后面，意思是让数据库忽略一个或多个索引。</p>
<h4 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h4><p>为<strong>强制</strong>MySQL使用一个特定的索引。</p>
<p>例如我们之前的例子，北京市太多了，可能有索引也不会走，我们可以强制他用索引。</p>
<p>use index只是给数据库参考，它可以不接受你的参考。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo搭建博客详细过程</title>
    <url>/2020/07/07/%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/</url>
    <content><![CDATA[<h1 id="hexo搭建博客"><a href="#hexo搭建博客" class="headerlink" title="hexo搭建博客"></a>hexo搭建博客</h1><p>​        我是跟着网上的博客一步步来搭建的，搭建过程中出现了各种各样的问题，折腾了半天，现写下我们搭建过程，可以给别人参考也记录自己的错误。</p>
<h2 id="前期软件准备"><a href="#前期软件准备" class="headerlink" title="前期软件准备"></a>前期软件准备</h2><h4 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h4><p>因为 hexo 是基于 node 框架的，所以我们首先需要下载安装node.js</p>
<p>官方网站下载：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/nodejs.png" alt="01"></p>
<p>（选择LTS版本，<code>Long Term Support</code>表示长期稳定版）</p>
<h4 id="git"><a href="#git" class="headerlink" title="git"></a>git</h4><p>因为 hexo 是基于 node 框架的，所以我们首先需要下载安装node.js。</p>
<p>官方网站下载：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br><img src= "/img/loading.gif" data-src="/2020/07/07/%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/git%E4%B8%8B%E8%BD%BD%E5%9B%BE.png" alt="02"></p>
<p>我下载的是Windows版本，点击后会自动根据环境弹出下载。</p>
<h2 id="安装hexo框架"><a href="#安装hexo框架" class="headerlink" title="安装hexo框架"></a>安装hexo框架</h2><p>我们可以通过cmd的npm下载，但是由于镜像源的速度会很慢，我们可以安装一个cnpm，是淘宝的一个源，速度比较快：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm	install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>安装cnpm后，用cnpm安装hexo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>安装完成后可以验证一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>





<h2 id="本地搭建"><a href="#本地搭建" class="headerlink" title="本地搭建"></a>本地搭建</h2><p>在自己的硬盘建立一个用于存放博客文件的空文件夹。例如我建立在了D:\blog</p>
<p>（在打开cmd命令符时记得要用管理员权限打开！）</p>
<ul>
<li>然后在cmd通过，cd命令指向这个空文件夹：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d:			 <span class="comment">#切换到c盘</span></span><br><span class="line"><span class="built_in">cd</span> blog		 <span class="comment">#切换到blog文件夹</span></span><br></pre></td></tr></table></figure>



<ul>
<li>使用hexo命令搭建一个博客：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>搭建过程需要一点时间（反正我很久= =）</p>
<p>搭建完成后显示<code>INFO Start blogging with Hexo!</code>就代表成功了。会在blog文件夹里生成博客的基础框架内容。</p>
<ul>
<li>启动博客：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server			#启动服务。	也可以 -p 端口号 来指定端口</span><br></pre></td></tr></table></figure>

<p>都可以可以用开头的第一个字母简写。</p>
<p>然后使用浏览器访问<code>http://server_ip</code>。这里默认端口号4000</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/hexo%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1.png" alt="03"></p>
<ul>
<li>新建文章</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"我的第一篇博客文章"</span></span><br></pre></td></tr></table></figure>

<p>就会在<code>D:\blog\source\_posts</code>下，生成一个<code>我的第一篇博客文章.md</code>的文本文件（文件建议用<code>Typora</code>编辑，也可以编辑好后移动至_posts文件夹下）</p>
<ul>
<li>生成静态网页</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean			<span class="comment"># 清除所有记录</span></span><br><span class="line">hexo generate		<span class="comment"># 生成静态网页</span></span><br></pre></td></tr></table></figure>

<p>生成网页后可以更新最新的内容，然后可以启动博客用浏览器本地查看。</p>
<h2 id="部署至GitHub"><a href="#部署至GitHub" class="headerlink" title="部署至GitHub"></a>部署至GitHub</h2><h3 id="创建博客仓库"><a href="#创建博客仓库" class="headerlink" title="创建博客仓库"></a>创建博客仓库</h3><p>我们先登陆GitHub（不会有人没有吧），然后新建一个仓库.</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="04"></p>
<ul>
<li>用户部署个人博客的GitHub仓库的命名必须符合特定要求，要使用<code>用户名.github.io</code>命名。</li>
</ul>
<p>然后点<code>Create repository</code>创建即可。 </p>
<h3 id="安装git部署插件"><a href="#安装git部署插件" class="headerlink" title="安装git部署插件"></a>安装git部署插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>​        这个插件相当于是沟通你本地数据与github仓库的通道,之后在每次本地数据编辑完后都要用到它,现在有了通道,本地数据,还有部署的仓库,只差怎样部署了</p>
<h3 id><a href="#" class="headerlink" title></a></h3><p>然后要配置blog文件夹下的<code>_config.yml</code>文件，可以用<strong>记事本</strong>或者<strong>Notepad++</strong>打开编辑：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/%E9%85%8D%E7%BD%AE%E5%89%8D.png" alt="05"></p>
<p>打开后，拉到最底部找到deploy:</p>
<p>然后type后加上git，并添加repo。repo后面的网址就是新建仓库的网址。</p>
<p>输入完成后：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/%E5%AE%8C%E6%88%90%E5%90%8E.png" alt="06"></p>
<p><strong>注意事项：</strong>这个配置文件的<code>:</code>后面一定要接一个空格。</p>
<p>保存文件，回到cmd，设置git的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email *********@qq.com	<span class="comment"># 设置git邮箱（git的注册邮箱）</span></span><br><span class="line"></span><br><span class="line">git config --global user.name <span class="string">'****'</span>			<span class="comment"># 设置用户名（git的注册昵称）</span></span><br></pre></td></tr></table></figure>



<p>最后使用hexo命令上传：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy	<span class="comment"># 上传到gitee</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在上传时，需要再次输入gitee的注册邮箱作为username，账户密码作为password</span></span><br></pre></td></tr></table></figure>



<p>上传完成之后，仓库就会多出以下文件</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/%E4%BB%93%E5%BA%93%E6%96%87%E4%BB%B6.png" alt="07"></p>
<p>然后可以浏览器打开远端的博客，就用刚才创建的仓库名称作为网址打开。</p>
<p>例如我的博客：<code>yuanqi-er.github.io</code></p>
<p><strong>这时候，hexo对github部署完毕！博客也终算搭建成功！</strong></p>
<h1 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h1><p>接下来我们可以为我们的hexo博客修改一下主题，我们可以下载一个主题：</p>
<p><a href="https://github.com/litten/hexo-theme-yilia这是github上的一个比较热门的主题，我们拿来用用" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia这是github上的一个比较热门的主题，我们拿来用用</a></p>
<p>我们还是在cmd的blog目录下，下载这个主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia</span><br><span class="line"></span><br><span class="line">#把这个git上的主题克隆到themes&#x2F;yilia的目录下。</span><br></pre></td></tr></table></figure>

<p>ps：贼慢，建议翻墙！</p>
<p>克隆到themes/yilia的目录下后，打开之前用过的配置文件<code>_config.yml</code>，找到这个东东：</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/07/%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/%E6%8D%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.png" alt="08"></p>
<p>把hexo默认的landscape主题换成我们的yilia，保存退出。</p>
<p>然后重新clean，然后重新生成一下generate，然后重新start一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>进去浏览器看一下效果。可以就推送到github上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
